<!DOCTYPE html>
<!--
================================================================================
DFP: GRAVITY FIELD DYNAMICS VISUAL v1
Distributed Field Processing - Dual Tetrahedron Field Closure Visualization
================================================================================

Copyright (c) 2026 Stephen Nelson / Field Dynamics
https://github.com/field-dynamics

================================================================================
MIT LICENSE
================================================================================

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

================================================================================
ABOUT THIS VISUALIZATION
================================================================================

Paper:   Distributed Field Processing VI: Deriving the Gravitational Constant 
         from Spacetime Topology
Author:  Stephen Nelson
Date:    February 2026

This standalone visualization demonstrates the dual tetrahedral Field Chamber
structure described in DFP Paper VI:

  - Stellated octahedron geometry (two interpenetrating tetrahedra)
  - Field closure cycles driven by Pi digits in base 8 (OEIS A006941)
  - 8 Coupling Ports (4 per tetrahedron): 2 TIME + 6 SPATIAL faces
  - Port aperture domain boundaries projected onto enclosing sphere
  - Field Origin glow at the geometric center

The animation runs 3 complete field closure cycles, then repeats.
Each closure cycle activates all 8 faces exactly once.

================================================================================
TECHNICAL NOTES
================================================================================

Dependencies:
  - Three.js r128 (loaded via CDN)
  - No other external dependencies

Pi Base-8 Validation:
  - Uses OEIS A006941 verified digits (first 300)
  - Preflight checksum validation prevents corrupted data
  - Polynomial hash: 1687952315 (any digit change fails validation)

Browser Support:
  - Modern browsers with WebGL support
  - Tested: Chrome, Firefox, Safari, Edge

================================================================================
-->
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DFP: Gravity Field Dynamics Visual v1</title>
    <meta name="author" content="Stephen Nelson">
    <meta name="copyright" content="(c) 2026 Stephen Nelson / Field Dynamics">
    <meta name="license" content="MIT">
    <meta name="description"
        content="Interactive visualization of the dual tetrahedral Field Chamber structure from DFP Paper VI: Deriving the Gravitational Constant from Spacetime Topology">

    <!-- Three.js Library (CDN) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <style>
        /* =====================================================================
           CSS DESIGN SYSTEM - Enterprise Quality
           ===================================================================== */

        :root {
            /* Color Palette */
            --bg-dark: #181818;
            --bg-panel: rgba(15, 15, 25, 0.95);
            --bg-section: rgba(30, 30, 50, 0.6);
            --text-primary: #ffffff;
            --text-secondary: #a0a0b0;
            --text-muted: #606070;

            /* Tetrahedron Colors - Blue and Yellow */
            --tet-a-color: #4488ff;
            --tet-b-color: #ffcc00;

            /* Accent Colors */
            --accent-primary: #4af;
            --accent-success: #4CAF50;

            /* Typography */
            --font-main: 'Segoe UI', -apple-system, BlinkMacSystemFont, sans-serif;
            --font-mono: 'Consolas', 'Monaco', 'Courier New', monospace;

            /* Spacing */
            --gap-sm: 8px;
            --gap-md: 16px;
            --gap-lg: 24px;

            /* Transitions */
            --transition-fast: 0.15s ease;
        }

        /* Reset */
        *,
        *::before,
        *::after {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html,
        body {
            width: 100%;
            height: 100%;
            overflow: hidden;
        }

        body {
            background: var(--bg-dark);
            color: var(--text-primary);
            font-family: var(--font-main);
            font-size: 14px;
            line-height: 1.5;
        }

        /* =====================================================================
           LAYOUT - Canvas fills entire screen
           ===================================================================== */

        #canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            z-index: 1;
        }

        #canvas-container canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* =====================================================================
           LEFT PANEL - Slide-out Drawer
           ===================================================================== */

        #left-panel {
            display: none !important;
        }

        #left-panel.open {
            transform: translateX(0);
        }

        /* Toggle Button */
        #panel-toggle {
            display: none !important;
        }

        #panel-toggle:hover {
            background: rgba(68, 136, 255, 0.2);
            color: var(--text-primary);
        }

        #left-panel.open+#panel-toggle {
            left: 360px;
        }

        /* Panel Header */
        .panel-header {
            padding: var(--gap-md);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .panel-header h1 {
            font-size: 14px;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 2px;
            line-height: 1.3;
        }

        .panel-header .subtitle {
            font-size: 10px;
            color: var(--text-muted);
        }

        /* Panel Section */
        .panel-section {
            padding: var(--gap-md);
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
        }

        .panel-section h3 {
            font-size: 10px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: var(--text-muted);
            margin-bottom: var(--gap-sm);
        }

        /* Structure Buttons - Simple stacked list */
        .structure-list {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }

        .structure-btn {
            width: 100%;
            padding: 10px 12px;
            background: transparent;
            border: none;
            border-radius: 4px;
            color: var(--text-muted);
            font-size: 13px;
            text-align: left;
            cursor: pointer;
            transition: all var(--transition-fast);
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .structure-btn:hover {
            background: rgba(255, 255, 255, 0.05);
            color: var(--text-secondary);
        }

        .structure-btn.active {
            background: rgba(255, 255, 255, 0.08);
            color: var(--text-primary);
        }

        .structure-btn .indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.2);
            transition: all var(--transition-fast);
        }

        .structure-btn.active .indicator {
            background: var(--accent-primary);
        }

        /* Spacer */
        .panel-spacer {
            flex: 1;
        }

        /* Control Buttons */
        .control-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 6px;
        }

        .control-btn {
            padding: 10px 8px;
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            color: var(--text-secondary);
            font-size: 11px;
            cursor: pointer;
            transition: all var(--transition-fast);
        }

        .control-btn:hover {
            background: rgba(255, 255, 255, 0.08);
            color: var(--text-primary);
        }

        .control-btn.active {
            background: rgba(68, 136, 255, 0.15);
            border-color: rgba(68, 136, 255, 0.3);
            color: var(--accent-primary);
        }

        /* =====================================================================
           FIELD MECHANICS SECTION
           ===================================================================== */

        .field-mechanics {
            font-size: 12px;
        }

        .mechanics-list {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .mechanic-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 4px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
        }

        .mechanic-row:last-child {
            border-bottom: none;
        }

        .mechanic-label {
            color: var(--text-secondary);
            font-size: 11px;
        }

        .mechanic-value {
            color: var(--text-primary);
            font-family: var(--font-mono);
            font-size: 11px;
            text-align: right;
        }

        .mechanics-note {
            margin-top: 10px;
            padding-top: 8px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            font-size: 10px;
            color: var(--text-secondary);
            line-height: 1.5;
            text-align: center;
        }

        /* =====================================================================
           INFO PANEL - Top Right
           ===================================================================== */

        #info-panel {
            display: none !important;
        }

        #info-panel h2 {
            font-size: 14px;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: var(--gap-sm);
        }

        #info-panel .subtitle {
            font-size: 11px;
            color: var(--text-secondary);
            margin-bottom: var(--gap-md);
            padding-bottom: var(--gap-sm);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .info-section {
            margin-bottom: var(--gap-md);
        }

        .info-section h3 {
            font-size: 10px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: var(--accent-primary);
            margin-bottom: var(--gap-sm);
        }

        .info-section p {
            font-size: 11px;
            color: var(--text-secondary);
            line-height: 1.5;
        }

        /* =====================================================================
           CLOSURE STEPS DISPLAY
           ===================================================================== */

        .closure-steps {
            font-family: var(--font-mono);
            font-size: 11px;
            line-height: 1.6;
            max-height: 280px;
            overflow-y: auto;
            overflow-x: hidden;
            scrollbar-width: none;
            /* Firefox */
            -ms-overflow-style: none;
            /* IE/Edge */
        }

        .closure-steps::-webkit-scrollbar {
            display: none;
            /* Chrome/Safari/Opera */
        }

        .closure-step {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 2px 0;
        }

        .closure-step.active {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 3px;
            padding: 2px 4px;
            margin: 0 -4px;
        }

        .step-num {
            color: var(--text-muted);
            min-width: 18px;
        }

        .step-pi {
            color: var(--text-secondary);
            min-width: 14px;
        }

        .step-arrow {
            color: var(--text-muted);
        }

        .step-face {
            font-weight: 600;
        }

        .step-face.tet-a {
            color: var(--tet-a-color);
        }

        .step-face.tet-b {
            color: var(--tet-b-color);
        }

        .step-time {
            color: #ffd700;
            font-size: 10px;
        }

        .step-dup {
            color: var(--text-muted);
            font-size: 9px;
            font-style: italic;
        }

        .step-cumsum {
            color: var(--accent-primary);
            font-size: 11px;
        }

        .step-vertex {
            font-weight: 600;
            padding: 1px 4px;
            border-radius: 3px;
            background: rgba(255, 255, 255, 0.1);
        }

        .step-vertex.tet-a {
            color: var(--tet-a-color);
        }

        .step-vertex.tet-b {
            color: var(--tet-b-color);
        }

        .step-count {
            color: var(--text-muted);
            font-size: 10px;
            margin-left: auto;
        }

        .info-legend {
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            padding-top: var(--gap-sm);
            margin-top: var(--gap-sm);
        }

        .closure-mode-label {
            font-size: 10px;
            color: var(--text-muted);
            margin-bottom: 4px;
        }

        /* =====================================================================
           DEFINITIONS MODAL - Full-screen overlay for formal definitions
           ===================================================================== */

        .modal-overlay {
            position: fixed;
            inset: 0;
            z-index: 1000;
            background: rgba(5, 5, 10, 0.92);
            backdrop-filter: blur(8px);
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }

        .modal-overlay.open {
            opacity: 1;
            visibility: visible;
        }

        .modal-container {
            width: 90%;
            max-width: 900px;
            max-height: 85vh;
            background: var(--bg-panel);
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-radius: 12px;
            display: flex;
            flex-direction: column;
            transform: scale(0.95) translateY(20px);
            transition: transform 0.3s ease;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
        }

        .modal-overlay.open .modal-container {
            transform: scale(1) translateY(0);
        }

        .modal-header {
            padding: var(--gap-md) var(--gap-lg);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            align-items: center;
            justify-content: space-between;
            flex-shrink: 0;
        }

        .modal-header h2 {
            font-size: 18px;
            font-weight: 600;
            color: var(--text-primary);
            margin: 0;
        }

        .modal-header .subtitle {
            font-size: 12px;
            color: var(--text-muted);
            margin-top: 2px;
        }

        .modal-close {
            width: 32px;
            height: 32px;
            border: none;
            background: rgba(255, 255, 255, 0.1);
            color: var(--text-secondary);
            border-radius: 6px;
            cursor: pointer;
            font-size: 18px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all var(--transition-fast);
        }

        .modal-close:hover {
            background: rgba(255, 100, 100, 0.3);
            color: #ff6666;
        }

        .modal-toolbar {
            padding: var(--gap-sm) var(--gap-lg);
            border-bottom: 1px solid rgba(255, 255, 255, 0.08);
            display: flex;
            gap: var(--gap-sm);
            flex-wrap: wrap;
            flex-shrink: 0;
        }

        .modal-search {
            flex: 1;
            min-width: 200px;
            padding: 8px 12px;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            color: var(--text-primary);
            font-family: var(--font-main);
            font-size: 13px;
        }

        .modal-search:focus {
            outline: none;
            border-color: var(--accent-primary);
        }

        .modal-search::placeholder {
            color: var(--text-muted);
        }

        .category-filters {
            display: flex;
            gap: 4px;
            flex-wrap: wrap;
        }

        .category-btn {
            padding: 6px 12px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            color: var(--text-secondary);
            font-size: 11px;
            font-weight: 500;
            cursor: pointer;
            transition: all var(--transition-fast);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .category-btn:hover {
            background: rgba(255, 255, 255, 0.1);
            color: var(--text-primary);
        }

        .category-btn.active {
            background: var(--accent-primary);
            border-color: var(--accent-primary);
            color: #000;
        }

        .modal-content {
            flex: 1;
            overflow-y: auto;
            padding: var(--gap-md) var(--gap-lg);
            scrollbar-width: thin;
            scrollbar-color: rgba(255, 255, 255, 0.2) transparent;
        }

        .modal-content::-webkit-scrollbar {
            width: 6px;
        }

        .modal-content::-webkit-scrollbar-track {
            background: transparent;
        }

        .modal-content::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 3px;
        }

        .definition-category {
            margin-bottom: var(--gap-lg);
        }

        .definition-category h3 {
            font-size: 12px;
            font-weight: 600;
            color: var(--accent-primary);
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: var(--gap-sm);
            padding-bottom: 6px;
            border-bottom: 1px solid rgba(68, 170, 255, 0.3);
        }

        .definition-item {
            padding: var(--gap-sm) var(--gap-md);
            margin-bottom: var(--gap-sm);
            background: rgba(30, 30, 50, 0.5);
            border-radius: 6px;
            border-left: 3px solid transparent;
            transition: all var(--transition-fast);
        }

        .definition-item:hover {
            background: rgba(40, 40, 60, 0.7);
            border-left-color: var(--accent-primary);
        }

        .definition-item.highlight {
            border-left-color: var(--tet-a-color);
            background: rgba(68, 136, 255, 0.1);
        }

        .definition-term {
            font-weight: 600;
            color: var(--text-primary);
            font-size: 14px;
            margin-bottom: 4px;
        }

        .definition-text {
            color: var(--text-secondary);
            font-size: 13px;
            line-height: 1.6;
        }

        .definition-text code {
            background: rgba(0, 0, 0, 0.3);
            padding: 2px 6px;
            border-radius: 3px;
            font-family: var(--font-mono);
            font-size: 12px;
            color: var(--tet-b-color);
        }

        .definition-meta {
            margin-top: 6px;
            font-size: 11px;
            color: var(--text-muted);
        }

        .no-results {
            text-align: center;
            padding: var(--gap-lg);
            color: var(--text-muted);
        }

        .modal-footer {
            padding: var(--gap-sm) var(--gap-lg);
            border-top: 1px solid rgba(255, 255, 255, 0.08);
            font-size: 11px;
            color: var(--text-muted);
            text-align: center;
            flex-shrink: 0;
        }

        /* Definitions button in control grid */
        .btn-definitions {
            grid-column: 1 / -1;
            margin-top: var(--gap-sm);
            background: rgba(68, 170, 255, 0.15) !important;
            border-color: rgba(68, 170, 255, 0.3) !important;
        }

        .btn-definitions:hover {
            background: rgba(68, 170, 255, 0.25) !important;
        }
    </style>
</head>

<body>
    <!-- =====================================================================
         HTML STRUCTURE
         ===================================================================== -->

    <!-- 3D Canvas Container -->
    <div id="canvas-container"></div>

    <!-- Left Panel - Slide-out Drawer -->
    <div id="left-panel">
        <!-- Header -->
        <div class="panel-header">
            <h1>DFP: Visual Gravity Field Dynamics v1</h1>
            <div class="subtitle">Dual Tetrahedron Chambers with Field Closure</div>
        </div>

        <!-- Structure & Animation -->
        <div class="panel-section">
            <h3>Display</h3>
            <div class="structure-list">
                <button id="btn-tet-a" class="structure-btn" data-level="1">
                    <span class="indicator"></span>
                    Tetrahedron A
                </button>
                <button id="btn-tet-b" class="structure-btn" data-level="2">
                    <span class="indicator"></span>
                    Tetrahedron B
                </button>
                <button id="btn-origin" class="structure-btn" data-level="3">
                    <span class="indicator"></span>
                    Field Origin
                </button>
                <button id="btn-ports" class="structure-btn" data-level="4">
                    <span class="indicator"></span>
                    Coupling Ports
                </button>
                <button id="btn-field-closure" class="structure-btn active" data-level="5">
                    <span class="indicator"></span>
                    Field Closure
                </button>
                <button id="btn-field-closure-step" class="structure-btn" data-level="6">
                    <span class="indicator"></span>
                    Field Closure (Step)
                </button>
            </div>
        </div>

        <!-- Spacer -->
        <div class="panel-spacer"></div>

        <!-- Controls -->
        <div class="panel-section">
            <h3>Controls</h3>
            <div class="control-grid">
                <button id="btn-lock" class="control-btn active">Unlock</button>
                <button id="btn-reset" class="control-btn">Reset</button>
                <button id="btn-definitions" class="control-btn btn-definitions">Definitions</button>
            </div>
        </div>

        <!-- Spacer -->
        <div class="panel-spacer"></div>

        <!-- 
            ================================================================
            FIELD DYNAMICS PANEL
            ================================================================
            Displays calculated and topological constants for Field Closure.
            
            (3+1) SPACETIME - SPHERE PACKING TOPOLOGY:
            ============================================================
            A gravity field in k=4 packing has 12 neighboring gravity 
            fields (cuboctahedral sphere packing). In (3+1) spacetime:
            
              - 12 neighbors = 12 ports
              - 4 ACTIVE ports (Tetrahedron A)
              - 8 CLOSED ports (structural blocking)
              - 4 + 8 = 12
            
            SUBSPACE:
            ============================================================
            Tetrahedron B exists in subspace. It is required to balance
            the field but is separate from the 12-port (3+1) structure.
            ============================================================
            
            CALCULATED VALUES (computed by JavaScript):
              - Field Envelope:      λ̄_C = ℏ/(mₑc) ≈ 386 fm
              - Aperture Throughput: η = √(π/k) ≈ 88.6%
              - Closure Frequency:   f = c/λ̄_C ≈ 7.76×10²⁰ Hz
              - Closure Period:      T = 1/f ≈ 1.29×10⁻²¹ s
              - Bits per Closure:    bits = 2k × d = 8 × 3 = 24
            
            TOPOLOGICAL CONSTANTS (derived from k=4):
              - Topology Packing:    k = 4 (simplex theorem: d+1)
              - Active Ports:        4 (Tet A in 3+1 space)
              - Closed per Cycle:    8 (structural blocking)
              - Total Ports:         12 (sphere packing neighbors)
              - State Encoding:      d = 3 bits (log₂(2k) = 3)
              - Isotropic Coupling:  k² = 16 (4×4 coupling channels)
            ================================================================
        -->
        <div class="panel-section field-mechanics">
            <h3>Field Dynamics</h3>
            <div class="mechanics-list">
                <!-- CALCULATED: λ̄_C = ℏ/(mₑc) - Reduced Compton wavelength -->
                <div class="mechanic-row">
                    <span class="mechanic-label">Field Envelope</span>
                    <span class="mechanic-value" id="field-envelope">--</span>
                </div>
                <!-- TOPOLOGICAL: k = d+1 = 4 from simplex theorem -->
                <div class="mechanic-row">
                    <span class="mechanic-label">Topology Packing</span>
                    <span class="mechanic-value">k = 4</span>
                </div>
                <!-- CALCULATED: η = √(π/k) - geometric coupling efficiency -->
                <div class="mechanic-row">
                    <span class="mechanic-label">Aperture Throughput</span>
                    <span class="mechanic-value" id="aperture-throughput">--</span>
                </div>
                <!-- (3+1) SPACETIME: Tet A has 4 active ports -->
                <div class="mechanic-row">
                    <span class="mechanic-label">Active Ports</span>
                    <span class="mechanic-value">4 (Tet A)</span>
                </div>
                <!-- (3+1) SPACETIME: 8 closed ports (structural blocking) -->
                <div class="mechanic-row">
                    <span class="mechanic-label">Closed per Cycle</span>
                    <span class="mechanic-value">8</span>
                </div>
                <!-- (3+1) SPACETIME: 12 neighbors = 4 active + 8 closed -->
                <div class="mechanic-row">
                    <span class="mechanic-label">Total Ports</span>
                    <span class="mechanic-value">12</span>
                </div>
                <!-- CALCULATED: f = c/λ̄_C - electron Compton frequency -->
                <div class="mechanic-row">
                    <span class="mechanic-label">Closure Frequency</span>
                    <span class="mechanic-value" id="settlement-freq">--</span>
                </div>
                <!-- CALCULATED: T = 1/f - closure cycle period -->
                <div class="mechanic-row">
                    <span class="mechanic-label">Closure Period</span>
                    <span class="mechanic-value" id="closure-period">--</span>
                </div>
                <!-- CALCULATED: bits = 2k × d = 8 × 3 = 24 -->
                <div class="mechanic-row">
                    <span class="mechanic-label">Bits per Closure</span>
                    <span class="mechanic-value" id="bits-per-closure">--</span>
                </div>
                <!-- TOPOLOGICAL: d = log₂(2k) = 3 bits to address 8 vertices -->
                <div class="mechanic-row">
                    <span class="mechanic-label">State Encoding</span>
                    <span class="mechanic-value">3-bit (0-7)</span>
                </div>
                <!-- TOPOLOGICAL: k² = 16 total coupling channels (4×4 tetrad) -->
                <div class="mechanic-row">
                    <span class="mechanic-label">Isotropic Coupling</span>
                    <span class="mechanic-value">k² = 16</span>
                </div>
            </div>
            <div class="mechanics-note">
                <div>Tet A → 3+1 spacetime</div>
                <div>Tet B → subspace</div>
                <div>Linked via Field Origin</div>
            </div>
        </div>
    </div>

    <!-- Panel Toggle Button (after panel for CSS sibling selector) -->
    <button id="panel-toggle">☰</button>

    <!-- Info Panel - Top Right -->
    <div id="info-panel">
        <h2>Field Closure</h2>

        <div class="info-section">
            <h3>Current Closure</h3>
            <div id="closure-steps" class="closure-steps">
                <!-- Dynamically populated -->
            </div>
        </div>

        <div class="info-section info-legend">
            <h3>Legend</h3>
            <p>
                <span style="color: var(--tet-a-color);">A0-A3</span> = Tet A faces<br>
                <span style="color: var(--tet-b-color);">B0-B3</span> = Tet B faces<br>
                <span style="color: #ffd700;">★</span> = TIME face (apex)
            </p>
        </div>
    </div>

    <!-- =====================================================================
         DEFINITIONS MODAL - Full-screen overlay for formal definitions
         ===================================================================== -->
    <div id="definitions-modal" class="modal-overlay">
        <div class="modal-container">
            <div class="modal-header">
                <div>
                    <h2>Engine Definitions</h2>
                    <div class="subtitle">GFD Model Terminology Reference</div>
                </div>
                <button class="modal-close" id="modal-close" aria-label="Close">&times;</button>
            </div>
            <div class="modal-toolbar">
                <input type="text" class="modal-search" id="definition-search" placeholder="Search definitions..."
                    autocomplete="off">
                <div class="category-filters" id="category-filters">
                    <!-- Dynamically populated -->
                </div>
            </div>
            <div class="modal-content" id="definitions-content">
                <!-- Dynamically populated -->
            </div>
            <div class="modal-footer">
                Press <kbd style="background: rgba(255,255,255,0.1); padding: 2px 6px; border-radius: 3px;">Esc</kbd> to
                close &bull;
                Source: ENGINE_DEFINITIONS.md
            </div>
        </div>
    </div>

    <!-- =====================================================================
         JAVASCRIPT - COMPLETE STANDALONE ENGINE
         ===================================================================== -->
    <script>
        /**
         * ==========================================================================
         * STELLATED OCTAHEDRON FIELD CLOSURE ENGINE
         * =========================================================================
         * 
         * Copyright (c) 2026 Stephen Nelson / Field Dynamics
         * Licensed under the MIT License(see header comment)
         * 
         * A complete, standalone visualization of the dual tetrahedral structure
         * undergoing field closure cycles driven b Pi digits (base 8).
         * 
         * Architecture:
         * -------------
         *   CONSTANTS              - Physical and topological parameters
         *   PiBase8Validator       - Preflight validation of pi digit integrity
         *   StellatedOctahedronRenderer - Core 3D rendering with Three.js
         *   FieldClosureEngine     - Animation an closure cycle logic
         * 
         * Key Features:
         * -------------
         *   - Dual tetrahedra (stellated octahedron / Merkaba geometry)
         *   - Pi base-8 driven vertex traversal with checksum validation
         *   - 8 Coupling Ports: 2 TIME (apex faces) + 6 SPATIAL (base faces)
         *   - Interactive camera controls with axis locking
         *   - Real-time closure cycle animationwith visual feedback
         * 
         * ==========================================================================
         */

        // =========================================================================
        // CONSTANTS
        // =========================================================================

        const CONSTANTS = {
            // =====================================================================
            // TOPOLOGY
            // =====================================================================
            topology: {
                k: 4,           // Coupling ports per tetrahedron
                d: 3,           // Spatial dimensions
                vertices: 8,    // Total vertices (2^d)
            },

            // =====================================================================
            // COLORS - Blue (Tet A) and Yellow (Tet B)
            // =====================================================================
            colors: {
                tetA: 0x4488ff,          // Blue
                tetB: 0xffcc00,          // Yellow/Gold
                background: 0x181818,    // Dark background
                highlight: 0xffffff,     // White highlight
                fieldOrigin: 0xffffff,  // White glow at center
            },

            // =====================================================================
            // VERTEX ENCODING
            // Binary encoding: XYZ where each bit is 0 or 1
            // Parity determines tetrahedron: ODD -> Tet A, EVEN -> Tet B
            // =====================================================================
            vertices: {
                encoding: {
                    '000': { x: -1, y: -1, z: -1, tet: 'B', index: 0 },
                    '001': { x: -1, y: -1, z: +1, tet: 'A', index: 1 },
                    '010': { x: -1, y: +1, z: -1, tet: 'A', index: 2 },
                    '011': { x: -1, y: +1, z: +1, tet: 'B', index: 3 },
                    '100': { x: +1, y: -1, z: -1, tet: 'A', index: 4 },
                    '101': { x: +1, y: -1, z: +1, tet: 'B', index: 5 },
                    '110': { x: +1, y: +1, z: -1, tet: 'B', index: 6 },
                    '111': { x: +1, y: +1, z: +1, tet: 'A', index: 7 },
                },
                // Tet A: ODD parity (1 or 3 bits set) - apex at 111
                tetA: ['001', '010', '100', '111'],
                // Tet B: EVEN parity (0 or 2 bits set) - apex at 000
                tetB: ['000', '011', '101', '110'],
            },

            // =====================================================================
            // PI DIGITS (Base 8) - 300 digits for 10+ closure cycles
            // Pi (octal) = 3.1103755242102643021514230630505600670163211220111...
            // Verified source: OEIS A006941 (https://oeis.org/A006941)
            // =====================================================================
            pi: {
                // OEIS A006941 - First 300 octal digits of Pi (verified)
                digits_base8: [
                    3, 1, 1, 0, 3, 7, 5, 5, 2, 4, 2, 1, 0, 2, 6, 4, 3, 0, 2, 1,  // 1-20
                    5, 1, 4, 2, 3, 0, 6, 3, 0, 5, 0, 5, 6, 0, 0, 6, 7, 0, 1, 6,  // 21-40
                    3, 2, 1, 1, 2, 2, 0, 1, 1, 1, 6, 0, 2, 1, 0, 5, 1, 4, 7, 6,  // 41-60
                    3, 0, 7, 2, 0, 0, 2, 0, 2, 7, 3, 7, 2, 4, 6, 1, 6, 6, 1, 1,  // 61-80
                    6, 3, 3, 1, 0, 4, 5, 0, 5, 1, 2, 0, 2, 0, 7, 4, 6, 1, 6, 1,  // 81-100
                    5, 0, 0, 2, 3, 3, 5, 7, 3, 7, 1, 2, 4, 3, 1, 5, 4, 7, 4, 6,  // 101-120
                    4, 7, 2, 2, 0, 6, 1, 5, 4, 6, 0, 1, 2, 6, 0, 5, 1, 5, 5, 7,  // 121-140
                    4, 4, 5, 7, 4, 2, 4, 1, 5, 6, 4, 7, 7, 4, 1, 1, 5, 2, 6, 6,  // 141-160
                    5, 5, 5, 2, 4, 3, 4, 1, 1, 0, 5, 7, 1, 1, 0, 2, 6, 6, 5, 3,  // 161-180
                    5, 4, 6, 1, 1, 3, 6, 3, 7, 5, 4, 3, 3, 6, 4, 2, 3, 0, 4, 1,  // 181-200
                    3, 5, 1, 5, 1, 4, 3, 3, 7, 5, 5, 3, 2, 6, 0, 5, 7, 7, 7, 2,  // 201-220
                    7, 1, 3, 3, 3, 6, 4, 0, 1, 5, 3, 3, 7, 5, 5, 7, 3, 4, 3, 4,  // 221-240
                    1, 5, 3, 7, 6, 6, 5, 5, 2, 1, 1, 4, 7, 7, 2, 2, 6, 5, 6, 4,  // 241-260
                    7, 6, 2, 2, 0, 2, 1, 3, 7, 0, 4, 5, 4, 3, 7, 7, 1, 4, 4, 4,  // 261-280
                    4, 5, 0, 3, 1, 4, 5, 0, 7, 5, 4, 7, 1, 0, 5, 5, 4, 7, 5, 6   // 281-300
                ],
                // Checksum: length=300, sum=1032, weightedSum=167584, polyHash=1687952315
            },

            // =====================================================================
            // FACE DEFINITIONS - Which 3 vertices make up each face
            // A face completes when ALL 3 of its vertices have been visited
            // Face names use OPPOSITE vertex convention (e.g., FACE_A7 is opposite V7)
            // =====================================================================
            faceVertices: {
                'FACE_A1': { vertices: new Set([2, 4, 7]), tetId: 'A', role: 'SPATIAL', faceIdx: 1 },
                'FACE_A2': { vertices: new Set([1, 4, 7]), tetId: 'A', role: 'SPATIAL', faceIdx: 2 },
                'FACE_A4': { vertices: new Set([1, 2, 7]), tetId: 'A', role: 'SPATIAL', faceIdx: 0 },
                'FACE_A7': { vertices: new Set([1, 2, 4]), tetId: 'A', role: 'TIME', faceIdx: 3 },    // TIME face
                'FACE_B0': { vertices: new Set([3, 5, 6]), tetId: 'B', role: 'TIME', faceIdx: 3 },    // TIME face
                'FACE_B3': { vertices: new Set([0, 5, 6]), tetId: 'B', role: 'SPATIAL', faceIdx: 1 },
                'FACE_B5': { vertices: new Set([0, 3, 6]), tetId: 'B', role: 'SPATIAL', faceIdx: 2 },
                'FACE_B6': { vertices: new Set([0, 3, 5]), tetId: 'B', role: 'SPATIAL', faceIdx: 0 },
            },

            // =====================================================================
            // VERTEX TO FACES MAPPING - Which faces contain each vertex
            // When a vertex is visited, it contributes to completing these faces
            // =====================================================================
            vertexToFaces: {
                0: ['FACE_B3', 'FACE_B5', 'FACE_B6'],  // V0 is in 3 Tet B faces
                1: ['FACE_A2', 'FACE_A4', 'FACE_A7'],  // V1 is in 3 Tet A faces
                2: ['FACE_A1', 'FACE_A4', 'FACE_A7'],  // V2 is in 3 Tet A faces
                3: ['FACE_B0', 'FACE_B5', 'FACE_B6'],  // V3 is in 3 Tet B faces
                4: ['FACE_A1', 'FACE_A2', 'FACE_A7'],  // V4 is in 3 Tet A faces
                5: ['FACE_B0', 'FACE_B3', 'FACE_B6'],  // V5 is in 3 Tet B faces
                6: ['FACE_B0', 'FACE_B3', 'FACE_B5'],  // V6 is in 3 Tet B faces
                7: ['FACE_A1', 'FACE_A2', 'FACE_A4'],  // V7 is in 3 Tet A faces
            },

            // =====================================================================
            // VERTEX INFO - Tetrahedron assignment by parity
            // =====================================================================
            vertexInfo: {
                0: { tetId: 'B', binary: '000' },  // Even parity -> Tet B
                1: { tetId: 'A', binary: '001' },  // Odd parity -> Tet A
                2: { tetId: 'A', binary: '010' },  // Odd parity -> Tet A
                3: { tetId: 'B', binary: '011' },  // Even parity -> Tet B
                4: { tetId: 'A', binary: '100' },  // Odd parity -> Tet A
                5: { tetId: 'B', binary: '101' },  // Even parity -> Tet B
                6: { tetId: 'B', binary: '110' },  // Even parity -> Tet B
                7: { tetId: 'A', binary: '111' },  // Odd parity -> Tet A
            },
        };


        // =========================================================================
        // DFP GRAVITY FIELD DYNAMICS DEFINITIONS
        // Authoritative terminology reference from dfp_gravity_field_dynamics_definitions.json
        // =========================================================================

        const DEFINITIONS_DATA = {
            "title": "DFP Gravity Field Dynamics Definitions",
            "description": "Authoritative terminology reference for Distributed Field Processing (DFP) and Gravity Field Dynamics.",
            "version": "1.0",
            "categories": [
                {
                    "name": "Foundation",
                    "definitions": [
                        { "term": "Field Closure Function (FC_Σ)", "definition": "The function that couples the field object and NET Field at the closure boundary Σ. FC_Σ enforces compatibility between the two configurations and produces the registered boundary state B*_Σ. FC_Σ operates continuously: as an object moves through the NET Field, it does not fire once but operates continuously, producing a continuously updated registered state. Field closure is not a third physical field; it is the function that resolves underdetermination in the coupled field description. The chain: READ → SETTLE, producing B*_Σ." },
                        { "term": "Settlement", "definition": "What the field closure function DOES. When the field object couples with the NET Field at Σ, where both exist in the same local conditions, field closure enforces compatibility. Settlement is the process by which this coupling resolves to a unique state. Settlement is not a separate mechanism from field closure; it is what FC_Σ executes. The terminology distinguishes the function (FC_Σ) from its execution (settlement). Processing is the method: distributed constraint enforcement via the elliptic field equation." },
                        { "term": "NET Field", "definition": "The external gravitational environment in which a field object is embedded. The gravitational configuration induced by sources outside the object's region, characterized by the local geometry ℓ(x). Like a river carrying effects of everything upstream, the NET Field is what the object encounters here, now." },
                        { "term": "Field Object", "definition": "A matter configuration with stress-energy content. The entity whose stress-energy participates in gravitational coupling with the NET Field. Any concentration of stress-energy: a planet, star, galaxy, electron. Described as a unified configuration because field closure couples the total stress-energy, not the internal arrangement." },
                        { "term": "Closure Boundary", "definition": "The geometric locus (Σ) at which field object and NET Field meet, and where field closure resolves their coupling to a consistent state. The closure boundary is where field closure happens, not owned by either field, but the neutral interface between them." },
                        { "term": "Local Geometry Scale", "definition": "A characterization of the metric at position x, written ℓ(x), encoding local clock rates and length scales relative to infinity. In the weak-field limit: ℓ(x) = √(-g₀₀) ≈ 1 + Φ(x)/c². Where ℓ(x) < 1, clocks run slower (gravitational time dilation)." },
                        { "term": "Gravity", "definition": "The spatial gradient in local geometry created by coupling: g = -c²∇ℓ(x). Gravity is not separate from coupling; gravity is what coupling creates. Objects follow geodesics because they exist in the geometry that coupling created." }
                    ]
                },
                {
                    "name": "Field Closure Process",
                    "definitions": [
                        { "term": "Full-State Snapshot (FSS)", "definition": "The READ operation within field closure. Defined operationally: the closure update introduces no effective dissipation, no hysteresis, and no wake/drag in the static limit. This is testable: if we observed gravitational wakes from moving asteroids, FSS would be falsified. We do not observe them. FSS means the boundary state is a complete representation of the domain's state within the physical code subspace, not a lossy summary. Lossless because both configurations exist in the same local geometry ℓ(x)." },
                        { "term": "SETTLE", "definition": "The resolution phase within FC_Σ. After READ (FSS) captures both configurations, SETTLE resolves them to consistency. Because both configurations share the same local field state, they are inherently compatible. Settlement is constraint satisfaction made automatic by co-location. Processing is the method: distributed constraint enforcement via the elliptic field equation." },
                        { "term": "Field State Registration (B*_Σ)", "definition": "The outcome of settlement: the settled boundary state. What the field looks like after closure has enforced compatibility. This is the 'signed contract' from the canonical chain. The output B*_Σ is the gravitational field that distant observers respond to; gradients ∇ℓ(x) are gravity. When a field object couples, its configuration is encoded at Σ and propagates outward into the gravitational field." }
                    ]
                },
                {
                    "name": "Core Constants",
                    "definitions": [
                        { "term": "k = 4 (Field Closure Constant)", "definition": "The minimum number of faces required to enclose a 3D volume, from the simplex theorem. In d dimensions, d+1 points are required to enclose a region, so k = d + 1 = 3 + 1 = 4. Manifests as: tetrahedral geometry (4 faces), ADM constraints (1 Hamiltonian + 3 momentum), tetrad legs (1 timelike + 3 spacelike), LIGO polarizations (10 - 2k = 2 modes)." },
                        { "term": "d = 3 (Spatial Dimensions)", "definition": "The number of spatial dimensions, derived from the closure constant k. Formula: d = k - 1 = 4 - 1 = 3." },
                        { "term": "Field Envelope (r_e)", "definition": "The fundamental scale of gravity: r_e = 2.818 × 10⁻¹⁵ m (2.82 fm). Two independent routes converge on this value. Route 1 (Electromagnetic): r_e = e²/(4πε₀m_ec²), where electromagnetic self-energy equals rest mass energy. Route 2 (Gravitational Topology): r_e = k√(Gm_e/a₀), from the crossover condition where tetrad coupling meets the MOND scale. These routes use completely different physics (one contains no gravity, the other contains no electromagnetism), yet converge to 0.21%. This convergence is unique to the electron and establishes r_e as the unit of gravity." },
                        { "term": "Reduced Compton Wavelength (λ̄_C)", "definition": "The quantum mechanical scale of the electron: λ̄_C = ℏ/(m_e·c) = 3.86 × 10⁻¹³ m (386 fm). Defines the settlement frequency through f = c/λ̄_C. Related to but distinct from the classical electron radius r_e." },
                        { "term": "a₀ (MOND Acceleration Scale)", "definition": "The emergent acceleration scale a₀ ≈ 1.2 × 10⁻¹⁰ m/s² below which gravitational dynamics deviate from Newtonian predictions. From horizon thermodynamics: a₀ = cH/(2π). From gravity field geometry: a₀ = k²(Gm_e/r_e²) = 16Gm_e/r_e²." },
                        { "term": "k² = 16 (Isotropic Coupling)", "definition": "The number of coupling channels when gravity couples isotropically. The tetrad e^a_μ has two indices: the frame index 'a' runs 0-3 (four values), and the coordinate index 'μ' runs 0-3 (four values), giving 4 × 4 = 16 independent components. Gravity is isotropic (no direction preferred), so full coupling engages all 16 tetrad components simultaneously. This is not a fit parameter; it follows directly from the dimensionality of spacetime. The coupled acceleration becomes a = k² × Gm/r² = 16 × Gm/r²." },
                        { "term": "√(k/π) Frame Correction", "definition": "The measurement lens factor √(k/π) = √(4/π) = 1.128 that converts between flat-space predictions and curved-space observations. We observe through a flat local frame (characterized by k=4 tetrahedral closure) to a curved cosmological boundary (characterized by π). Example: The MOND relation predicts H_flat = 78.90 km/s/Mpc, but observations give H_measured = H_flat/√(k/π) = 69.92 km/s/Mpc. The field envelope r_e provides the anchor that makes this correction meaningful." },
                        { "term": "Aperture Throughput", "definition": "The geometric efficiency factor √(π/k) = √(π/4) ≈ 0.886 (88.6%). Represents the ratio of open area to total area when k=4 tetrahedral geometry interfaces with spherical field boundaries." },
                        { "term": "Processing Boundary (r_c)", "definition": "The radial distance at which x = |∇Φ|/a₀ = 1; the transition radius between Newtonian and deep-MOND regimes. Formula: r_c = √(GM/a₀). Inside r_c, coupling behaves approximately Newtonian. Outside r_c, coupling transitions to the low-acceleration regime. Σ (closure boundary) is the stage; r_c is one specific choice of Σ commonly used in spherically symmetric applications." },
                        { "term": "Interpolating Function μ(x)", "definition": "The function relating Newtonian and effective gravitational accelerations, derived from geometric constraints on field closure. Form: μ(x) = x/(1+x) where x = |∇Φ|/a₀. Asymptotic behavior: μ(x) → 1 as x → ∞ (Newtonian regime); μ(x) → x as x → 0 (deep-MOND regime). Exhibits reciprocal symmetry: μ(x) + μ(1/x) = 1." },
                        { "term": "H_flat (Flat-Space Hubble Constant)", "definition": "The Hubble constant predicted from the MOND relation in abstract flat space, before accounting for the measurement path: H_flat = 2πa₀/c = 78.90 km/s/Mpc. This is not what we observe because measurements pass through the k=4 field structure." },
                        { "term": "H_measured (Observed Hubble Constant)", "definition": "The Hubble constant as observed through the k=4 tetrad topology: H_measured = H_flat/√(k/π) = 78.90/1.128 = 69.92 km/s/Mpc. This matches GW170817 (70.0 ± 12) to 0.11%. The apparent 'Hubble tension' between early-universe (~67) and late-universe (~73) values reflects measurement scatter within the predicted ±6.2% range around 69.92." }
                    ]
                },
                {
                    "name": "Sphere Packing Topology",
                    "definitions": [
                        { "term": "12-Neighbor Sphere Packing", "definition": "In k=4 topology, each gravity field has 12 neighboring gravity fields arranged in cuboctahedral sphere packing. These 12 neighbors create the coupling channels through which field closure operates." },
                        { "term": "Active Ports", "definition": "The 4 coupling channels (of 12 total neighbors) through which energy flow occurs in (3+1) spacetime. These correspond to the 4 vertices of Tetrahedron A, which exists in observable spacetime. Active ports enable gravitational coupling with neighbors." },
                        { "term": "Closed Ports", "definition": "The 8 coupling channels (of 12 total neighbors) that are structurally blocked in (3+1) spacetime. These provide structural containment. Total ports: 4 active + 8 closed = 12 neighbors." },
                        { "term": "Subspace (Tetrahedron B Domain)", "definition": "The domain where Tetrahedron B operates. Tet B exists in subspace, providing field balance through the complement operation, but its 4 ports do not appear as active channels in (3+1) spacetime. Tet B is required for stability but is separate from the 12-port (3+1) structure." }
                    ]
                },
                {
                    "name": "Field Dynamics",
                    "definitions": [
                        { "term": "Settlement Frequency (Closure Frequency)", "definition": "The rate at which field closure cycles complete, equal to the electron Compton frequency: f = c/λ̄_C = m_e·c²/ℏ ≈ 7.76 × 10²⁰ Hz. Derived from E = ℏω and E = m_e·c², giving ω = m_e·c²/ℏ." },
                        { "term": "Settlement Period (Closure Period)", "definition": "The time for one complete field closure cycle: T = 1/f = λ̄_C/c ≈ 1.29 × 10⁻²¹ seconds. The fundamental time unit of gravitational settlement." },
                        { "term": "Bits per Closure", "definition": "The information processed per closure cycle: 2k × d = 8 × 3 = 24 bits. Derived from: 2k = 8 vertices (stellated octahedron) × d = 3 bits per vertex (encoding 3 spatial coordinates as binary). Each closure cycle processes 24 bits of field state information." },
                        { "term": "State Encoding", "definition": "Each vertex position is encoded in d = 3 bits, representing the 8 possible states (0-7) of the stellated octahedron vertices. The encoding is 3-bit because log₂(2k) = log₂(8) = 3." }
                    ]
                },
                {
                    "name": "Geometry",
                    "definitions": [
                        { "term": "Stellated Octahedron", "definition": "The unique geometric structure satisfying all gravitational constraints: two interpenetrating tetrahedra (TetA and TetB) sharing a central point. Four independent roads in physics require this configuration: (1) Stability, a single tetrahedron has a preferred direction causing ghost instability; (2) Spinor structure, fermions require SL(2,C) double cover; (3) Chirality, gravity needs both A⁺ and A⁻ connections (Ashtekar); (4) Bimetric theory, ghost-free massive gravity requires two metrics (Hassan-Rosen). The stellated octahedron is the only geometry satisfying all four requirements. Contains 2k = 8 vertices, 8 faces (4 per tetrahedron), and a shared center (Field Origin)." },
                        { "term": "Field Origin", "definition": "The point (0, 0, 0) at the center of the stellated octahedron, equidistant from all 8 vertices at distance √3. Serves as the geometric bridge between TetrahedronA and TetrahedronB. All coupling between the two tetrahedra is mediated through this shared center. Also called the King's Chamber in some contexts." },
                        { "term": "Field Chamber", "definition": "The interior volume bounded by k=4 Coupling Ports; has tetrahedral geometry at scale r_e = 2.82 fm. A single unit of gravitational field structure." },
                        { "term": "Vertex", "definition": "One of the 8 corners of the stellated octahedron, labeled 0 through 7 by their binary representation of cube coordinates. Each vertex belongs to exactly one tetrahedron (determined by parity) and participates in exactly 3 faces (all faces of its tetrahedron except the one opposite it)." },
                        { "term": "Complement", "definition": "For vertex V, the complement is 7−V. Complements always belong to opposite tetrahedra because bit-inversion flips parity. The complement operation is the mechanism by which knowledge of one vertex immediately determines a vertex in the opposite tetrahedron, requiring no signal propagation." }
                    ]
                },
                {
                    "name": "Tetrahedra",
                    "definitions": [
                        { "term": "TetrahedronA (TetA)", "definition": "The tetrahedron containing vertices {1, 2, 4, 7}, all odd-parity vertices (odd number of 1-bits in binary representation). Operates as the linear, causal, observable channel in (3+1) spacetime. Contains 3 spatial faces and 1 time face (FACE_A7). Corresponds to the physical metric g_μν in bimetric gravity. In code: constant TETA." },
                        { "term": "TetrahedronB (TetB)", "definition": "The tetrahedron containing vertices {0, 3, 5, 6}, all even-parity vertices. Operates as the non-linear, instantaneous, subspace channel. Contains 3 spatial faces and 1 time face (FACE_B0). Corresponds to the reference metric f_μν in bimetric gravity. In code: constant TETB. At each traversal step, TetB's state is determined simultaneously with TetA's through the complement operation, requiring zero additional time." },
                        { "term": "Complementary Pair", "definition": "One of the four pairs (0,7), (1,6), (2,5), (3,4) where each pair spans both tetrahedra. Every vertex has exactly one complement, and that complement is always in the opposite tetrahedron. These pairs establish the cross-tetrahedron coupling structure." },
                        { "term": "3+1 Structure", "definition": "The decomposition of spacetime into 3 spatial dimensions plus 1 time dimension, reflected in the tetrahedral geometry where each tetrahedron has 3 SPATIAL faces + 1 TIME face. The first two digits of π in base-8 (3.1...) encode this structure: digit 3 represents d=3 spatial dimensions, digit 1 represents +1 time dimension, together giving k=4." }
                    ]
                },
                {
                    "name": "Faces",
                    "definitions": [
                        { "term": "Coupling Port (Face)", "definition": "A triangular face of one tetrahedron, defined by 3 vertices. Each tetrahedron has 4 faces, giving 8 total. Named by tetrahedron and opposite vertex: FACE_A1 is the TetA face opposite vertex 1, containing vertices {2, 4, 7}. A face completes when all 3 of its constituent vertices have been visited by the traversal." },
                        { "term": "Spatial Face", "definition": "A face whose opposite vertex is not the vertex with all coordinates matching (vertex 7 for TetA, vertex 0 for TetB). There are 3 spatial faces per tetrahedron, 6 total: FACE_A1, FACE_A2, FACE_A4 (TetA) and FACE_B3, FACE_B5, FACE_B6 (TetB). These correspond to the three spatial dimensions of the 3+1 decomposition." },
                        { "term": "Time Face", "definition": "The single face per tetrahedron whose opposite vertex has the extremal coordinate signature. FACE_A7 (opposite vertex 7 = (+1,+1,+1), containing vertices {1,2,4}) for TetA, and FACE_B0 (opposite vertex 0 = (−1,−1,−1), containing vertices {3,5,6}) for TetB. There are exactly 2 time faces across the full stellated octahedron." },
                        { "term": "3+1 Pattern", "definition": "The observation that within a macro-cycle, the 3 spatial faces of a tetrahedron tend to complete at or before the 1 time face. Measured as weak ordering (spatial step ≤ time step, ties included). Observed at approximately 75–80% of cycles for both TetA and TetB." }
                    ]
                },
                {
                    "name": "Trigram",
                    "definitions": [
                        { "term": "Trigram", "definition": "The geometric shape of a face: a triangle defined by 3 vertices and 3 edges. When describing the traversal, a trigram refers to the ordered sequence in which the 3 vertices of a face are visited. For example, the trigram (4, 7, 2) for FACE_A1 means vertex 4 was read first, then vertex 7, then vertex 2. Each face has 3! = 6 possible trigrams, and across 8 faces there are 48 possible (face, trigram) combinations." },
                        { "term": "Trigram Order", "definition": "The specific permutation of a face's 3 vertices as determined by their visitation order during a macro-cycle. Recorded per face per cycle and stored in the macro-cycle record. The trigram order is the raw data from which tetragram analysis is derived." }
                    ]
                },
                {
                    "name": "Tetragram",
                    "definitions": [
                        { "term": "Tetragram", "definition": "The functional subdivision of a coupling port (face) into 4 coupling channels following the 3+1 recursion. Each face, viewed as a triforce, decomposes into 3 corner channels (one anchored at each vertex) and 1 central channel (the medial region). A tetragram is thus the minimal unit of the (k−1)+1 = 3+1 structure within a single face. Total across the stellated octahedron: 8 faces × 4 channels = 32 tetragrams." },
                        { "term": "Corner Channel", "definition": "One of the 3 vertex-anchored regions within a tetragram. A corner channel activates when its corresponding vertex is explicitly read by the traversal. Named by face and vertex: FACE_A1.C2 is the corner channel for vertex 2 within face FACE_A1. There are 24 corner channels total (8 faces × 3 corners)." },
                        { "term": "Central Channel", "definition": "The medial region at the center of a tetragram, activated when all 3 corner channels of that face have been activated, that is, when the face completes. Named with suffix .X: FACE_A1.X is the central channel for face FACE_A1. There are 8 central channels total (one per face). Central activation is an emergent completion event, not a direct vertex read." },
                        { "term": "Tetragram Activation Sequence", "definition": "The chronologically ordered list of all 32 tetragram channel activations within a single macro-cycle. Corners activate on the step their vertex is read; centrals activate on the step the face completes. Sorted by (step, type) with corners before centrals at the same step." }
                    ]
                },
                {
                    "name": "Traversal",
                    "definitions": [
                        { "term": "Pi Base-8 Encoding", "definition": "The traversal is driven by the digits of π in base 8. Starting with the integer part (3), each digit is added to a cumulative sum, and the current vertex is cumsum mod 8. This deterministic sequence visits vertices in both tetrahedra, driving face completions and tetragram activations. The encoding is fixed (π does not change), making all analysis reproducible." },
                        { "term": "Cumulative Sum (Cumsum)", "definition": "The running total of all pi base-8 digits processed so far. The current vertex is always cumsum mod 8. The cumsum also defines orbit boundaries (every time cumsum crosses a multiple of 8) and is verified for integrity at every step." },
                        { "term": "Orbit", "definition": "A segment of the traversal defined by cumsum // 8. Each time the cumulative sum crosses a multiple of 8, a new orbit begins. Orbits are a structural unit of the cumulative sum arithmetic, not directly related to face completions." },
                        { "term": "Macro-Cycle (Field Closure Cycle)", "definition": "One complete coverage of all 8 coupling ports. A macro-cycle begins after the previous cycle's reset and ends when all 8 faces have had their 3 vertices read. At completion, all face trackers reset and a new cycle begins. The macro-cycle is the fundamental unit of field closure." }
                    ]
                },
                {
                    "name": "Channels",
                    "definitions": [
                        { "term": "Explicit Channel", "definition": "The traversal channel that directly reads a vertex. At each step, the explicit channel identifies which vertex is visited (cumsum mod 8), which tetrahedron it belongs to, and which 3 faces it touches. Only explicit reads advance face completion state." },
                        { "term": "Implicit Channel (Complement Channel)", "definition": "The traversal channel that instantaneously determines the complement vertex (7 − v) at each step. The implicit channel identifies which vertex in the opposite tetrahedron is specified, and which 3 faces of that tetrahedron are addressed. The implicit channel does not advance face completion; it provides simultaneous state awareness of the opposite tetrahedron without requiring additional processing time." },
                        { "term": "Dual-Channel Architecture", "definition": "The principle that at every traversal step, both tetrahedra have fully determined state: one through explicit vertex read, the other through implicit complement. This is why field closure operates at the full Compton frequency f_C rather than f_C/2. If both tetrahedra required explicit processing (sequential model), the effective period would double and frequency would halve." }
                    ]
                },
                {
                    "name": "Metrics",
                    "definitions": [
                        { "term": "Field Closure Integrity", "definition": "The binary pass/fail check: did all 8 faces complete exactly once per macro-cycle, with all 3 unique vertices per face? This is the primary engine certification metric. Observed rate: 100% across all tested cycles." },
                        { "term": "Face Completion Rank", "definition": "The ordinal position (1st through 8th) at which a face completes within a macro-cycle. Used to analyze completion dynamics, specifically which faces tend to finish early or late. The time face tends to finish last, but this is an observational pattern within complete closures, not a failure condition." },
                        { "term": "Last-Mile Ratio", "definition": "The ratio of the gap between the 2nd and 3rd vertex reads to the gap between the 1st and 2nd reads for a face. Observed at approximately 2:1, meaning the final vertex takes roughly twice as long to arrive as the second one. This is consistent with the coupon collector effect." },
                        { "term": "Burst Completion", "definition": "The event where multiple faces complete at the same traversal step. Occurs when a single vertex read satisfies the final requirement for 2 or more faces simultaneously. Observed in approximately 57% of central activation gaps." },
                        { "term": "Read Efficiency", "definition": "The ratio of new vertex reads to total vertex touches across a cycle. Each cycle requires exactly 24 new reads (8 faces × 3 vertices) but may accumulate many more redundant touches where a vertex hits a face that has already recorded it." }
                    ]
                },
                {
                    "name": "Derived Properties",
                    "definitions": [
                        { "term": "Electron Spin (ℏ/2)", "definition": "Derived from the stellated octahedron's face structure, not assumed. The 8 faces divide into 2 TIME faces (pointing inward toward the Field Origin) and 6 SPATIAL faces (pointing outward). The TIME face fraction is f_time = 2/8 = 1/4. Total angular momentum per orbit is L = 2ℏ. Electron spin S = f_time × L = (1/4) × 2ℏ = ℏ/2, exactly. The electron couples to the TIME component of field closure, yielding half-integer spin from pure geometry." },
                        { "term": "Charge Quantum (1/3)", "definition": "The minimum charge quantum q = 1/d = 1/3, derived from the port ratio. Quark charges are integer multiples: up quark = +2/3 = 2 × (1/3), down quark = -1/3 = -1 × (1/3)." },
                        { "term": "Fine Structure Constant (α)", "definition": "The electromagnetic coupling constant α ≈ 1/137. In DFP, α appears in the gravitational constant formula with exponent 1 + (3+1) + (3+1)² = 1 + 4 + 16 = 21. This represents coupling through: time (1), full spacetime (4), and dual spacetime interaction (16). The hierarchy between gravity and electromagnetism (factor of ~10⁴³) emerges from α^(D+D²) where D = 3+1 = 4." },
                        { "term": "Fine Structure Connection (137)", "definition": "The electron contains exactly 137 Merkaba orbits, equal to 1/α (inverse fine structure constant). Information content: 137 orbits × 24 bits/orbit ≈ 3300 bits. The fine structure constant determines how many closure cycles constitute one stable electron." },
                        { "term": "Gravitational Constant (G) from Topology", "definition": "G derives from the 3+1 structure of spacetime with zero adjustable parameters: G = [(3+1)²+1]/[3(3+1)+1] × α^[1+(3+1)+(3+1)²] × ℏc/m_e². The numerator 17 = (3+1)²+1 and denominator 13 = 3(3+1)+1 are topological factors from the stellated octahedron. The exponent 21 = 1+4+16 represents the coupling hierarchy. This predicts G = 6.67 × 10⁻¹¹ m³/(kg·s²), matching measurement to 0.12%." },
                        { "term": "Hierarchy Problem (Resolved)", "definition": "Why is gravity ~10⁴³ times weaker than electromagnetism? In DFP, this is not fine-tuning but a consequence of the (3+1) coupling structure. Electromagnetic interactions couple at level 1 (one factor of α). Gravitational interactions traverse the full 1 + D + D² hierarchy where D = 4. The ratio α^(D+D²) = α^20 ≈ 10⁻⁴³ emerges from spacetime topology rather than requiring explanation." },
                        { "term": "Ghost Instability", "definition": "A single tetrahedron (one Field Chamber) produces an unstable theory with a ghost, a field mode with negative kinetic energy causing unbounded particle creation. This is the Boulware-Deser ghost that challenged massive gravity for 70 years. The stellated octahedron (dual tetrahedra) eliminates the ghost because the opposite orientations cancel the instability. This is why field closure requires both tetrahedra." }
                    ]
                }
            ]
        };

        // Flatten the JSON structure into the array format the modal expects
        const ENGINE_DEFINITIONS = DEFINITIONS_DATA.categories.flatMap(category =>
            category.definitions.map(def => ({
                category: category.name,
                term: def.term,
                definition: def.definition,
                code: null,
                related: []
            }))
        );



        // =========================================================================
        // DEFINITIONS MODAL
        // Modular overlay system for displaying formal definitions
        // =========================================================================

        class DefinitionsModal {
            constructor() {
                this.overlay = document.getElementById('definitions-modal');
                this.content = document.getElementById('definitions-content');
                this.searchInput = document.getElementById('definition-search');
                this.filtersContainer = document.getElementById('category-filters');
                this.closeBtn = document.getElementById('modal-close');

                this.activeCategory = 'all';
                this.searchTerm = '';

                this.init();
            }

            init() {
                // Build category filters
                this.buildFilters();

                // Render initial content
                this.render();

                // Event listeners
                this.closeBtn.addEventListener('click', () => this.close());
                this.overlay.addEventListener('click', (e) => {
                    if (e.target === this.overlay) this.close();
                });

                this.searchInput.addEventListener('input', (e) => {
                    this.searchTerm = e.target.value.toLowerCase();
                    this.render();
                });

                // Keyboard navigation
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape' && this.isOpen()) {
                        this.close();
                    }
                });
            }

            buildFilters() {
                // Get unique categories
                const categories = [...new Set(ENGINE_DEFINITIONS.map(d => d.category))];

                // Add "All" button
                let html = '<button class="category-btn active" data-category="all">All</button>';

                // Add category buttons
                categories.forEach(cat => {
                    html += `<button class="category-btn" data-category="${cat}">${cat}</button>`;
                });

                this.filtersContainer.innerHTML = html;

                // Add click handlers
                this.filtersContainer.querySelectorAll('.category-btn').forEach(btn => {
                    btn.addEventListener('click', () => {
                        this.filtersContainer.querySelectorAll('.category-btn').forEach(b => b.classList.remove('active'));
                        btn.classList.add('active');
                        this.activeCategory = btn.dataset.category;
                        this.render();
                    });
                });
            }

            render() {
                // Filter definitions
                let filtered = ENGINE_DEFINITIONS;

                if (this.activeCategory !== 'all') {
                    filtered = filtered.filter(d => d.category === this.activeCategory);
                }

                if (this.searchTerm) {
                    filtered = filtered.filter(d =>
                        d.term.toLowerCase().includes(this.searchTerm) ||
                        d.definition.toLowerCase().includes(this.searchTerm) ||
                        (d.code && d.code.toLowerCase().includes(this.searchTerm))
                    );
                }

                if (filtered.length === 0) {
                    this.content.innerHTML = '<div class="no-results">No definitions found matching your criteria.</div>';
                    return;
                }

                // Group by category
                const grouped = {};
                filtered.forEach(d => {
                    if (!grouped[d.category]) grouped[d.category] = [];
                    grouped[d.category].push(d);
                });

                // Build HTML
                let html = '';
                Object.entries(grouped).forEach(([category, definitions]) => {
                    html += `<div class="definition-category">`;
                    html += `<h3>${category}</h3>`;

                    definitions.forEach(d => {
                        const highlight = this.searchTerm && d.term.toLowerCase().includes(this.searchTerm);
                        html += `<div class="definition-item${highlight ? ' highlight' : ''}">`;
                        html += `<div class="definition-term">${this.highlightMatch(d.term)}</div>`;
                        html += `<div class="definition-text">${this.highlightMatch(this.formatDefinition(d.definition))}`;
                        if (d.code) {
                            html += ` <code>${d.code}</code>`;
                        }
                        html += `</div>`;
                        if (d.related && d.related.length > 0) {
                            html += `<div class="definition-meta">Related: ${d.related.join(', ')}</div>`;
                        }
                        html += `</div>`;
                    });

                    html += `</div>`;
                });

                this.content.innerHTML = html;
            }

            formatDefinition(text) {
                // Convert code references in backticks to code tags
                return text.replace(/`([^`]+)`/g, '<code>$1</code>');
            }

            highlightMatch(text) {
                if (!this.searchTerm) return text;
                const regex = new RegExp(`(${this.escapeRegex(this.searchTerm)})`, 'gi');
                return text.replace(regex, '<mark style="background: rgba(68, 170, 255, 0.3); color: inherit; padding: 0 2px; border-radius: 2px;">$1</mark>');
            }

            escapeRegex(string) {
                return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
            }

            open() {
                this.overlay.classList.add('open');
                this.searchInput.focus();
                document.body.style.overflow = 'hidden';
            }

            close() {
                this.overlay.classList.remove('open');
                document.body.style.overflow = '';
            }

            isOpen() {
                return this.overlay.classList.contains('open');
            }

            toggle() {
                if (this.isOpen()) {
                    this.close();
                } else {
                    this.open();
                }
            }
        }


        // =========================================================================
        // PI BASE-8 PREFLIGHT VALIDATION
        // Scientific verification of pi digits before field closure execution
        // =========================================================================

        const PiBase8Validator = {
            /**
             * PREFLIGHT VALIDATION FOR PI BASE-8 DIGITS
             * 
             * Uses a cryptographic-style hash of the full sequence to verify
             * data integrity. Any single digit error will cause validation to fail.
             * 
             * Reference: OEIS A006941 (https://oeis.org/A006941)
             * 
             * Why this matters:
             * - Pi base-8 digits drive Field Closure vertex selection (0-7)
             * - Incorrect digits would produce wrong traversal patterns
             * - Pi is irrational/non-repeating; the hash validates the full sequence
             */

            // Expected values for the full 300-digit sequence (OEIS A006941)
            EXPECTED: {
                length: 300,
                sum: 1032,              // Sum of all 300 digits
                weightedSum: 167584,    // Position-weighted sum: sum(digit[i] * (i+1))
                polyHash: 1687952315,   // Polynomial hash for collision resistance
            },

            /**
             * Compute polynomial hash of digit sequence
             * hash = sum(digit[i] * BASE^i) mod (2^31 - 1)
             * This is a standard string hashing technique with good collision resistance
             */
            computePolyHash(digits) {
                const PRIME = 2147483647;  // 2^31 - 1 (Mersenne prime)
                const BASE = 31;
                let hash = 0;
                let basePower = 1;

                for (let i = 0; i < digits.length; i++) {
                    hash = (hash + digits[i] * basePower) % PRIME;
                    basePower = (basePower * BASE) % PRIME;
                }

                return hash;
            },

            /**
             * Compute all checksums for the digit sequence
             */
            computeChecksums(digits) {
                let sum = 0;
                let weightedSum = 0;

                for (let i = 0; i < digits.length; i++) {
                    sum += digits[i];
                    weightedSum += digits[i] * (i + 1);
                }

                return {
                    length: digits.length,
                    sum: sum,
                    weightedSum: weightedSum,
                    polyHash: this.computePolyHash(digits),
                };
            },

            /**
             * Validate the pi base-8 sequence against expected checksums
             * @returns {Object} Validation result with status and details
             */
            validate() {
                const digits = CONSTANTS.pi.digits_base8;
                const computed = this.computeChecksums(digits);
                const expected = this.EXPECTED;

                // Check all values match
                const lengthOK = computed.length === expected.length;
                const sumOK = computed.sum === expected.sum;
                const weightedOK = computed.weightedSum === expected.weightedSum;
                const hashOK = computed.polyHash === expected.polyHash;

                const passed = lengthOK && sumOK && weightedOK && hashOK;

                return {
                    passed,
                    computed,
                    expected,
                    details: {
                        length: { ok: lengthOK, computed: computed.length, expected: expected.length },
                        sum: { ok: sumOK, computed: computed.sum, expected: expected.sum },
                        weightedSum: { ok: weightedOK, computed: computed.weightedSum, expected: expected.weightedSum },
                        polyHash: { ok: hashOK, computed: computed.polyHash, expected: expected.polyHash },
                    },
                };
            },

            /**
             * Log validation results to console
             */
            logResult(result) {
                const status = result.passed ? 'PASSED' : 'FAILED';
                const color = result.passed ? '#4CAF50' : '#f44336';

                console.log(`%c[Pi Base-8 Validation] ${status}`, `color: ${color}; font-weight: bold;`);
                console.log(`  Length:      ${result.details.length.computed} (expected ${result.details.length.expected}) ${result.details.length.ok ? '✓' : '✗'}`);
                console.log(`  Sum:         ${result.details.sum.computed} (expected ${result.details.sum.expected}) ${result.details.sum.ok ? '✓' : '✗'}`);
                console.log(`  WeightedSum: ${result.details.weightedSum.computed} (expected ${result.details.weightedSum.expected}) ${result.details.weightedSum.ok ? '✓' : '✗'}`);
                console.log(`  PolyHash:    ${result.details.polyHash.computed} (expected ${result.details.polyHash.expected}) ${result.details.polyHash.ok ? '✓' : '✗'}`);

                return result;
            },

            /**
             * Run validation and throw error if failed
             * Call this before starting field closure animation
             */
            assertValid() {
                const result = this.validate();
                this.logResult(result);

                if (!result.passed) {
                    const failures = Object.entries(result.details)
                        .filter(([k, v]) => !v.ok)
                        .map(([k, v]) => `${k}: got ${v.computed}, expected ${v.expected}`);
                    throw new Error(`Pi Base-8 Validation FAILED: ${failures.join('; ')}`);
                }

                return true;
            }
        };


        // =========================================================================
        // STELLATED OCTAHEDRON RENDERER CLASS
        // =========================================================================

        class StellatedOctahedronRenderer {
            /**
             * Core 3D rendering class for the stellated octahedron
             * (two interpenetrating tetrahedra forming the Merkaba)
             */
            constructor(container) {
                this.container = container;
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                this.clock = null;

                // Main container group - all objects rotate together
                this.containerGroup = null;

                // Groups for organized management
                this.groups = {
                    tetA: null,
                    tetB: null,
                    vertices: null,
                    sphere: null,
                    effects: null,
                };

                // Mesh references
                this.vertexMeshes = {};
                this.faceMeshes = { tetA: [], tetB: [] };
                this.edgeLines = { tetA: [], tetB: [] };
                this.portApertureData = null;
                this.fieldOrigin = null;

                // Tetrahedron vertices
                this.tetAVertices = null;
                this.tetBVertices = null;
                this.vertexPositions = {};

                // Animation state
                this.animationId = null;
                this.isDragging = false;
                this.prevMouse = { x: 0, y: 0 };
                this.autoRotate = true;
                this.rotationSpeed = 0.06;
                this.rotationVelocity = { x: 0, y: 0 };
                this.dampingFactor = 0.95;

                // Axis lock
                this.axisLocked = false;
                this._lockedSpinAngle = 0;

                // Scale
                this.scale = 2.0;

                // Colors
                this.tetAColor = CONSTANTS.colors.tetA;
                this.tetBColor = CONSTANTS.colors.tetB;
            }

            // =====================================================================
            // INITIALIZATION
            // =====================================================================

            init() {
                this._createClock();
                this._createScene();
                this._createCamera();
                this._createRenderer();
                this._createLights();
                this._createContainerGroup();
                this._createGroups();
                this._createStellatedOctahedron();
                this._createEnclosingSphere();
                this._createPortApertureCircles();
                this._createFieldOrigin();
                this._createTriforceLines();
                this._setupControls();
                this._setupResizeHandler();
                this._startAnimation();

                return this;
            }

            _createClock() {
                this.clock = new THREE.Clock();
            }

            _createScene() {
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(CONSTANTS.colors.background);
            }

            _createCamera() {
                const aspect = this.container.clientWidth / this.container.clientHeight;
                this.camera = new THREE.PerspectiveCamera(60, aspect, 0.1, 100);
                // Camera position (closer for tighter framing)
                this.camera.position.set(4.61, 3.46, 4.61);
                this.camera.lookAt(0, 0, 0);
            }

            _createRenderer() {
                this.renderer = new THREE.WebGLRenderer({
                    antialias: true,
                    alpha: true,
                    powerPreference: 'high-performance'
                });
                this.renderer.setSize(this.container.clientWidth, this.container.clientHeight);
                this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                this.container.appendChild(this.renderer.domElement);

                // Handle WebGL context loss (browsers may reclaim GPU resources
                // when the iframe is scrolled off-screen).
                const self = this;
                this.renderer.domElement.addEventListener('webglcontextlost', (e) => {
                    e.preventDefault();
                    console.warn('[Stellated] WebGL context lost, pausing render loop.');
                    if (self.animationId) cancelAnimationFrame(self.animationId);
                }, false);
                this.renderer.domElement.addEventListener('webglcontextrestored', () => {
                    console.log('[Stellated] WebGL context restored, resuming.');
                    self._startAnimation();
                }, false);
            }

            _createLights() {
                const ambient = new THREE.AmbientLight(0xffffff, 0.6);
                this.scene.add(ambient);

                const directional = new THREE.DirectionalLight(0xffffff, 0.4);
                directional.position.set(5, 10, 5);
                this.scene.add(directional);
            }

            _createContainerGroup() {
                this.containerGroup = new THREE.Group();
                this.containerGroup.name = 'stellated-octahedron-container';
                this.scene.add(this.containerGroup);
            }

            _createGroups() {
                Object.keys(this.groups).forEach(key => {
                    this.groups[key] = new THREE.Group();
                    this.groups[key].name = key;
                    this.containerGroup.add(this.groups[key]);
                });
            }

            // =====================================================================
            // STELLATED OCTAHEDRON GEOMETRY
            // =====================================================================

            _createStellatedOctahedron() {
                const s = this.scale;

                // Build vertex position map from binary encoding
                Object.entries(CONSTANTS.vertices.encoding).forEach(([binary, data]) => {
                    this.vertexPositions[binary] = new THREE.Vector3(
                        data.x * s,
                        data.y * s,
                        data.z * s
                    );
                });

                // Tet A vertices (ODD parity) - apex at 111
                this.tetAVertices = [
                    this.vertexPositions['111'],  // APEX
                    this.vertexPositions['001'],
                    this.vertexPositions['010'],
                    this.vertexPositions['100']
                ];

                // Tet B vertices (EVEN parity) - apex at 000
                this.tetBVertices = [
                    this.vertexPositions['000'],  // APEX
                    this.vertexPositions['011'],
                    this.vertexPositions['101'],
                    this.vertexPositions['110']
                ];

                // Create edges
                this._createTetrahedronEdges(this.tetAVertices, this.tetAColor, this.groups.tetA, 'tetA');
                this._createTetrahedronEdges(this.tetBVertices, this.tetBColor, this.groups.tetB, 'tetB');

                // Create faces
                this._createTetrahedronFaces(this.tetAVertices, this.tetAColor, 0.15, this.groups.tetA, 'A');
                this._createTetrahedronFaces(this.tetBVertices, this.tetBColor, 0.10, this.groups.tetB, 'B');

                // Create clock ticks on TIME faces
                this._createTimeFaceClockTicks(this.tetAVertices, this.tetAColor, this.groups.tetA);
                this._createTimeFaceClockTicks(this.tetBVertices, this.tetBColor, this.groups.tetB);
            }

            _createTetrahedronEdges(vertices, color, group, groupId) {
                const edges = [
                    [0, 1], [0, 2], [0, 3],  // apex to base
                    [1, 2], [2, 3], [3, 1]   // base triangle
                ];

                edges.forEach(([i, j]) => {
                    const geometry = new THREE.BufferGeometry().setFromPoints([
                        vertices[i], vertices[j]
                    ]);
                    const material = new THREE.LineBasicMaterial({
                        color: color,
                        transparent: true,
                        opacity: 1.0
                    });
                    const line = new THREE.Line(geometry, material);
                    group.add(line);
                    this.edgeLines[groupId].push(line);
                });
            }

            _createTetrahedronFaces(vertices, color, opacity, group, tetId) {
                const faces = [
                    [0, 1, 2],  // Side face
                    [0, 2, 3],  // Side face
                    [0, 3, 1],  // Side face
                    [1, 3, 2]   // Base face (TIME)
                ];

                faces.forEach((faceIndices, faceIndex) => {
                    const geometry = new THREE.BufferGeometry();
                    const positions = new Float32Array([
                        vertices[faceIndices[0]].x, vertices[faceIndices[0]].y, vertices[faceIndices[0]].z,
                        vertices[faceIndices[1]].x, vertices[faceIndices[1]].y, vertices[faceIndices[1]].z,
                        vertices[faceIndices[2]].x, vertices[faceIndices[2]].y, vertices[faceIndices[2]].z,
                    ]);
                    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                    geometry.computeVertexNormals();

                    const material = new THREE.MeshBasicMaterial({
                        color: color,
                        transparent: true,
                        opacity: opacity,
                        side: THREE.DoubleSide,
                        depthWrite: false
                    });

                    const mesh = new THREE.Mesh(geometry, material);
                    mesh.userData = { tetId, faceIndex, originalOpacity: opacity };
                    group.add(mesh);

                    if (tetId === 'A') {
                        this.faceMeshes.tetA.push(mesh);
                    } else {
                        this.faceMeshes.tetB.push(mesh);
                    }
                });
            }

            _createTimeFaceClockTicks(vertices, color, group) {
                const v1 = vertices[1];
                const v2 = vertices[2];
                const v3 = vertices[3];

                const centroid = new THREE.Vector3()
                    .add(v1).add(v2).add(v3).divideScalar(3);

                const edge1 = new THREE.Vector3().subVectors(v2, v1);
                const edge2 = new THREE.Vector3().subVectors(v3, v1);
                const normal = new THREE.Vector3().crossVectors(edge1, edge2).normalize();

                const clockCenter = centroid.clone().add(normal.clone().multiplyScalar(0.02));
                const distToVertex = centroid.distanceTo(v1);
                const clockRadius = distToVertex * 0.16;
                const innerRadius = clockRadius * 0.7;
                const outerRadius = clockRadius * 0.95;

                const xAxis = edge1.clone().normalize();
                const yAxis = new THREE.Vector3().crossVectors(normal, xAxis).normalize();

                // 12 tick marks
                for (let i = 0; i < 12; i++) {
                    const angle = (i / 12) * Math.PI * 2;
                    const cos = Math.cos(angle);
                    const sin = Math.sin(angle);

                    const innerPoint = clockCenter.clone()
                        .add(xAxis.clone().multiplyScalar(cos * innerRadius))
                        .add(yAxis.clone().multiplyScalar(sin * innerRadius));
                    const outerPoint = clockCenter.clone()
                        .add(xAxis.clone().multiplyScalar(cos * outerRadius))
                        .add(yAxis.clone().multiplyScalar(sin * outerRadius));

                    const tickGeo = new THREE.BufferGeometry().setFromPoints([innerPoint, outerPoint]);
                    const tickMat = new THREE.LineBasicMaterial({
                        color: color,
                        transparent: true,
                        opacity: 0.9
                    });
                    group.add(new THREE.Line(tickGeo, tickMat));
                }

                // Circle outline
                const circlePoints = [];
                for (let i = 0; i <= 32; i++) {
                    const angle = (i / 32) * Math.PI * 2;
                    circlePoints.push(clockCenter.clone()
                        .add(xAxis.clone().multiplyScalar(Math.cos(angle) * clockRadius))
                        .add(yAxis.clone().multiplyScalar(Math.sin(angle) * clockRadius)));
                }
                const circleGeo = new THREE.BufferGeometry().setFromPoints(circlePoints);
                const circleMat = new THREE.LineBasicMaterial({
                    color: color,
                    transparent: true,
                    opacity: 0.5
                });
                group.add(new THREE.Line(circleGeo, circleMat));
            }

            // =====================================================================
            // ENCLOSING SPHERE
            // =====================================================================

            _createEnclosingSphere() {
                const sphereRadius = this.scale * Math.sqrt(3);
                const geometry = new THREE.SphereGeometry(sphereRadius, 24, 16);
                const material = new THREE.MeshBasicMaterial({
                    color: 0x333333,
                    wireframe: true,
                    transparent: true,
                    opacity: 0.08
                });
                const sphere = new THREE.Mesh(geometry, material);
                this.groups.sphere.add(sphere);
            }

            // =====================================================================
            // PORT APERTURE CIRCLES
            // =====================================================================

            _createPortApertureCircles() {
                this.portApertureData = {
                    tetA: { circles: [] },
                    tetB: { circles: [] },
                    allMeshes: []
                };

                this._createPortCirclesForTet('A', this.tetAColor, 0.7, 0.1);
                this._createPortCirclesForTet('B', this.tetBColor, 0.35, 0.04);
            }

            _createPortCirclesForTet(tetId, color, lineOpacity, discOpacity) {
                const vertices = tetId === 'A' ? this.tetAVertices : this.tetBVertices;
                const sphereRadius = this.scale * Math.sqrt(3);
                const portAngularRadius = Math.acos(-1 / 3) / 2;

                const faceIndices = [
                    [0, 1, 2], [0, 2, 3], [0, 3, 1], [1, 3, 2]
                ];

                for (let faceIndex = 0; faceIndex < 4; faceIndex++) {
                    const face = faceIndices[faceIndex];
                    const v0 = vertices[face[0]];
                    const v1 = vertices[face[1]];
                    const v2 = vertices[face[2]];

                    const centroid = new THREE.Vector3().add(v0).add(v1).add(v2).divideScalar(3);
                    const edge1 = new THREE.Vector3().subVectors(v1, v0);
                    const edge2 = new THREE.Vector3().subVectors(v2, v0);
                    const normal = new THREE.Vector3().crossVectors(edge1, edge2).normalize();

                    if (normal.dot(centroid) < 0) normal.negate();

                    const tangent1 = new THREE.Vector3();
                    if (Math.abs(normal.x) < 0.9) {
                        tangent1.set(1, 0, 0);
                    } else {
                        tangent1.set(0, 1, 0);
                    }
                    tangent1.cross(normal).normalize();
                    const tangent2 = new THREE.Vector3().crossVectors(normal, tangent1).normalize();

                    const circleRadius = sphereRadius * Math.sin(portAngularRadius);
                    const offsetFromCenter = sphereRadius * Math.cos(portAngularRadius);
                    const circleCenter = normal.clone().multiplyScalar(offsetFromCenter);

                    // Circle line
                    const circlePoints = [];
                    for (let i = 0; i <= 48; i++) {
                        const angle = (i / 48) * Math.PI * 2;
                        circlePoints.push(circleCenter.clone()
                            .add(tangent1.clone().multiplyScalar(Math.cos(angle) * circleRadius))
                            .add(tangent2.clone().multiplyScalar(Math.sin(angle) * circleRadius)));
                    }

                    const circleGeo = new THREE.BufferGeometry().setFromPoints(circlePoints);
                    const circleMat = new THREE.LineBasicMaterial({
                        color: color,
                        transparent: true,
                        opacity: lineOpacity
                    });
                    const circleLine = new THREE.Line(circleGeo, circleMat);
                    this.groups.sphere.add(circleLine);
                    this.portApertureData.allMeshes.push(circleLine);

                    // Filled disc
                    const discGeo = new THREE.CircleGeometry(circleRadius * 0.95, 48);
                    const discMat = new THREE.MeshBasicMaterial({
                        color: color,
                        transparent: true,
                        opacity: discOpacity,
                        side: THREE.DoubleSide,
                        depthWrite: false
                    });
                    const disc = new THREE.Mesh(discGeo, discMat);
                    disc.position.copy(circleCenter);
                    disc.lookAt(circleCenter.clone().add(normal));
                    this.groups.sphere.add(disc);
                    this.portApertureData.allMeshes.push(disc);

                    const tetData = tetId === 'A' ? this.portApertureData.tetA : this.portApertureData.tetB;
                    tetData.circles.push({
                        faceIndex,
                        line: circleLine,
                        disc: disc,
                        originalColor: color,
                        baseLineOpacity: lineOpacity,
                        baseDiscOpacity: discOpacity,
                        tetId
                    });
                }
            }

            // =====================================================================
            // FIELD ORIGIN (Vortex Eye / Coupling Center)
            // =====================================================================
            // 
            // The Field Origin is the central point where both tetrahedra share
            // their geometric center - the coupling point of the bimetric field.
            //
            // Size proportions based on the 4% ratio derived from geometric analysis:
            // - Vertex distance from center = sqrt(3) * scale
            // - Field Origin radius = 4% of vertex distance
            //
            // =====================================================================

            _createFieldOrigin() {
                // Field origin is ~4% of the characteristic dimension
                const FIELD_ORIGIN_RATIO = 0.04;
                const vertexDistance = Math.sqrt(3) * this.scale;
                const originRadius = vertexDistance * FIELD_ORIGIN_RATIO;

                const geometry = new THREE.SphereGeometry(originRadius, 32, 32);
                const material = new THREE.MeshBasicMaterial({
                    color: CONSTANTS.colors.fieldOrigin,
                    transparent: true,
                    opacity: 0.5,
                    depthWrite: false
                });
                this.fieldOrigin = new THREE.Mesh(geometry, material);
                this.fieldOrigin.position.set(0, 0, 0);
                this.containerGroup.add(this.fieldOrigin);
            }

            // =====================================================================
            // TRIFORCE SUBDIVISION LINES
            // =====================================================================

            _createTriforceLines() {
                const faceVertexIndices = [
                    [0, 1, 2], [0, 2, 3], [0, 3, 1], [1, 3, 2]
                ];

                // Tet A
                faceVertexIndices.forEach(indices => {
                    const v0 = this.tetAVertices[indices[0]];
                    const v1 = this.tetAVertices[indices[1]];
                    const v2 = this.tetAVertices[indices[2]];
                    this._addHeartTriangleLines(v0, v1, v2, 0x2255aa, 0.5);
                });

                // Tet B
                faceVertexIndices.forEach(indices => {
                    const v0 = this.tetBVertices[indices[0]];
                    const v1 = this.tetBVertices[indices[1]];
                    const v2 = this.tetBVertices[indices[2]];
                    this._addHeartTriangleLines(v0, v1, v2, 0xaa8800, 0.5);
                });
            }

            _addHeartTriangleLines(v0, v1, v2, color, opacity) {
                const m01 = new THREE.Vector3().addVectors(v0, v1).multiplyScalar(0.5);
                const m12 = new THREE.Vector3().addVectors(v1, v2).multiplyScalar(0.5);
                const m20 = new THREE.Vector3().addVectors(v2, v0).multiplyScalar(0.5);

                const edges = [[m01, m12], [m12, m20], [m20, m01]];

                edges.forEach(([a, b]) => {
                    const geometry = new THREE.BufferGeometry().setFromPoints([a, b]);
                    const material = new THREE.LineBasicMaterial({
                        color: color,
                        opacity: opacity,
                        transparent: true
                    });
                    this.groups.effects.add(new THREE.Line(geometry, material));
                });
            }

            // =====================================================================
            // ANIMATION CONTROLS
            // =====================================================================

            _setupControls() {
                const domElement = this.renderer.domElement;

                domElement.addEventListener('mousedown', (e) => {
                    this.isDragging = true;
                    this.prevMouse.x = e.clientX;
                    this.prevMouse.y = e.clientY;
                    this.rotationVelocity.x = 0;
                    this.rotationVelocity.y = 0;
                });

                domElement.addEventListener('mousemove', (e) => {
                    if (!this.isDragging) return;

                    const dx = e.clientX - this.prevMouse.x;
                    const dy = e.clientY - this.prevMouse.y;

                    if (this.axisLocked) {
                        this._applyLockedYRotation(dx * 0.01);
                        this.rotationVelocity.y = dx * 0.01;
                    } else {
                        this.containerGroup.rotation.y += dx * 0.01;
                        this.containerGroup.rotation.x += dy * 0.01;
                        this.rotationVelocity.x = dy * 0.01;
                        this.rotationVelocity.y = dx * 0.01;
                    }

                    this.prevMouse.x = e.clientX;
                    this.prevMouse.y = e.clientY;
                });

                domElement.addEventListener('mouseup', () => { this.isDragging = false; });
                domElement.addEventListener('mouseleave', () => { this.isDragging = false; });

                // Wheel zoom disabled: fixed camera prevents scroll-through crashes
                // when embedded in an iframe on a scrollable page.  Block the
                // event at the element level so it never reaches the browser.
                domElement.addEventListener('wheel', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                }, { passive: false });

                // Touch support
                domElement.addEventListener('touchstart', (e) => {
                    if (e.touches.length === 1) {
                        this.isDragging = true;
                        this.prevMouse.x = e.touches[0].clientX;
                        this.prevMouse.y = e.touches[0].clientY;
                    }
                }, { passive: true });

                domElement.addEventListener('touchmove', (e) => {
                    if (!this.isDragging || e.touches.length !== 1) return;
                    e.preventDefault();

                    const dx = e.touches[0].clientX - this.prevMouse.x;
                    const dy = e.touches[0].clientY - this.prevMouse.y;

                    if (this.axisLocked) {
                        this._applyLockedYRotation(dx * 0.01);
                    } else {
                        this.containerGroup.rotation.y += dx * 0.01;
                        this.containerGroup.rotation.x += dy * 0.01;
                    }

                    this.prevMouse.x = e.touches[0].clientX;
                    this.prevMouse.y = e.touches[0].clientY;
                }, { passive: false });

                domElement.addEventListener('touchend', () => { this.isDragging = false; }, { passive: true });
            }

            _setupResizeHandler() {
                window.addEventListener('resize', () => {
                    const width = this.container.clientWidth;
                    const height = this.container.clientHeight;
                    if (width === 0 || height === 0) return;

                    this.camera.aspect = width / height;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(width, height);
                });
            }

            _startAnimation() {
                const animate = () => {
                    this.animationId = requestAnimationFrame(animate);
                    const deltaTime = this.clock.getDelta();

                    if (!this.isDragging) {
                        this.rotationVelocity.x *= this.dampingFactor;
                        this.rotationVelocity.y *= this.dampingFactor;

                        if (this.axisLocked) {
                            if (Math.abs(this.rotationVelocity.y) > 0.0001) {
                                this._applyLockedYRotation(this.rotationVelocity.y);
                            }
                            if (this.autoRotate && Math.abs(this.rotationVelocity.y) < 0.001) {
                                this._applyLockedYRotation(this.rotationSpeed * deltaTime);
                            }
                        } else {
                            if (Math.abs(this.rotationVelocity.x) > 0.0001) {
                                this.containerGroup.rotation.x += this.rotationVelocity.x;
                            }
                            if (Math.abs(this.rotationVelocity.y) > 0.0001) {
                                this.containerGroup.rotation.y += this.rotationVelocity.y;
                            }
                            if (this.autoRotate &&
                                Math.abs(this.rotationVelocity.x) < 0.001 &&
                                Math.abs(this.rotationVelocity.y) < 0.001) {
                                this.containerGroup.rotation.y += this.rotationSpeed * deltaTime;
                            }
                        }
                    }

                    this.renderer.render(this.scene, this.camera);
                };

                animate();
            }

            // =====================================================================
            // AXIS LOCK
            // =====================================================================

            lockTimeFloor() {
                this.axisLocked = true;
                this._lockedSpinAngle = 0;
                this._updateLockedOrientation();
                this.rotationVelocity.x = 0;
                this.rotationVelocity.y = 0;
            }

            unlockAxis() {
                this.axisLocked = false;
                this._lockedSpinAngle = 0;
            }

            toggleAxisLock() {
                if (this.axisLocked) {
                    this.unlockAxis();
                } else {
                    this.lockTimeFloor();
                }
                return this.axisLocked;
            }

            _updateLockedOrientation() {
                const apexDirection = new THREE.Vector3(1, 1, 1).normalize();
                const upDirection = new THREE.Vector3(0, 1, 0);
                const alignQuat = new THREE.Quaternion().setFromUnitVectors(apexDirection, upDirection);
                const spinQuat = new THREE.Quaternion().setFromAxisAngle(
                    new THREE.Vector3(0, 1, 0),
                    this._lockedSpinAngle
                );
                this.containerGroup.quaternion.copy(alignQuat).premultiply(spinQuat);
            }

            _applyLockedYRotation(deltaY) {
                this._lockedSpinAngle += deltaY;
                this._updateLockedOrientation();
            }

            resetCamera() {
                this.camera.position.set(4.61, 3.46, 4.61);
                this.camera.lookAt(0, 0, 0);
                this.containerGroup.rotation.set(0, 0, 0);
                this.containerGroup.quaternion.set(0, 0, 0, 1);
                this.rotationVelocity.x = 0;
                this.rotationVelocity.y = 0;
                this._lockedSpinAngle = 0;
                if (this.axisLocked) {
                    this._updateLockedOrientation();
                }
            }

            // =====================================================================
            // VISIBILITY CONTROL
            // =====================================================================

            /**
             * Set visibility level for progressive reveal
             * Level 1: Tetrahedron A only
             * Level 2: Tetrahedron A + B
             * Level 3: Both Tetrahedra + Field Origin
             * Level 4: Everything (Tetrahedra + Origin + Ports)
             */
            setVisibilityLevel(level) {
                // Tetrahedron A - always visible at level 1+
                this.groups.tetA.visible = level >= 1;

                // Tetrahedron B - visible at level 2+
                this.groups.tetB.visible = level >= 2;

                // Field Origin - visible at level 3+
                if (this.fieldOrigin) {
                    this.fieldOrigin.visible = level >= 3;
                }

                // Coupling Ports (aperture circles on sphere) - visible at level 4
                this.groups.sphere.visible = level >= 4;

                // Triforce lines follow the tetrahedra visibility
                this.groups.effects.visible = level >= 2;
            }

            setTetAVisible(visible) {
                this.groups.tetA.visible = visible;
            }

            setTetBVisible(visible) {
                this.groups.tetB.visible = visible;
            }

            setFieldOriginVisible(visible) {
                if (this.fieldOrigin) {
                    this.fieldOrigin.visible = visible;
                }
            }

            setPortsVisible(visible) {
                this.groups.sphere.visible = visible;
            }

            // =====================================================================
            // FACE & PORT HIGHLIGHTING
            // =====================================================================

            pulseFace(tetId, faceIndex, duration = 1000) {
                const meshes = tetId === 'A' ? this.faceMeshes.tetA : this.faceMeshes.tetB;
                const mesh = meshes[faceIndex];
                if (!mesh) return;

                const baseColor = tetId === 'A' ? this.tetAColor : this.tetBColor;
                const origColor = new THREE.Color(baseColor);
                const targetColor = tetId === 'A' ? new THREE.Color(0x6da3cc) : new THREE.Color(0xccbe52);
                const baseOp = mesh.userData.originalOpacity;
                const maxOp = tetId === 'A' ? 0.64 : 0.48;

                const startTime = performance.now();
                const flashDur = duration * 0.25;
                const fadeDur = duration * 0.75;

                const animate = (t) => {
                    const elapsed = t - startTime;

                    if (elapsed < flashDur) {
                        const p = elapsed / flashDur;
                        mesh.material.color.lerpColors(origColor, targetColor, p);
                        mesh.material.opacity = baseOp + (maxOp - baseOp) * p;
                    } else if (elapsed < flashDur + fadeDur) {
                        const p = (elapsed - flashDur) / fadeDur;
                        mesh.material.color.lerpColors(targetColor, origColor, p);
                        mesh.material.opacity = maxOp - (maxOp - baseOp) * p;
                    } else {
                        mesh.material.color.copy(origColor);
                        mesh.material.opacity = baseOp;
                        return;
                    }
                    requestAnimationFrame(animate);
                };
                requestAnimationFrame(animate);
            }

            pulsePortAperture(tetId, faceIndex, duration = 1000) {
                const tetData = tetId === 'A' ? this.portApertureData.tetA : this.portApertureData.tetB;
                if (!tetData || !tetData.circles[faceIndex]) return;

                const circleData = tetData.circles[faceIndex];
                const origColor = new THREE.Color(circleData.originalColor);
                const targetColor = tetId === 'A' ? new THREE.Color(0xcccccc) : new THREE.Color(0xcccc88);
                const maxLineOp = tetId === 'A' ? 1.0 : 0.7;
                const maxDiscOp = tetId === 'A' ? 0.6 : 0.3;

                const startTime = performance.now();
                const flashDur = duration * 0.25;
                const fadeDur = duration * 0.75;

                const animate = (t) => {
                    const elapsed = t - startTime;

                    if (elapsed < flashDur) {
                        const p = elapsed / flashDur;
                        circleData.line.material.color.lerpColors(origColor, targetColor, p);
                        circleData.line.material.opacity = circleData.baseLineOpacity + (maxLineOp - circleData.baseLineOpacity) * p;
                        circleData.disc.material.color.lerpColors(origColor, targetColor, p);
                        circleData.disc.material.opacity = circleData.baseDiscOpacity + (maxDiscOp - circleData.baseDiscOpacity) * p;
                    } else if (elapsed < flashDur + fadeDur) {
                        const p = (elapsed - flashDur) / fadeDur;
                        circleData.line.material.color.lerpColors(targetColor, origColor, p);
                        circleData.line.material.opacity = maxLineOp - (maxLineOp - circleData.baseLineOpacity) * p;
                        circleData.disc.material.color.lerpColors(targetColor, origColor, p);
                        circleData.disc.material.opacity = maxDiscOp - (maxDiscOp - circleData.baseDiscOpacity) * p;
                    } else {
                        circleData.line.material.color.copy(origColor);
                        circleData.line.material.opacity = circleData.baseLineOpacity;
                        circleData.disc.material.color.copy(origColor);
                        circleData.disc.material.opacity = circleData.baseDiscOpacity;
                        return;
                    }
                    requestAnimationFrame(animate);
                };
                requestAnimationFrame(animate);
            }

            pulseFieldOrigin(duration = 800, color = 0xffffff) {
                if (!this.fieldOrigin) return;

                const startTime = performance.now();
                const pulseColor = new THREE.Color(color);

                const animate = (t) => {
                    const elapsed = t - startTime;
                    const progress = Math.min(elapsed / duration, 1);

                    let intensity;
                    if (progress < 0.3) {
                        intensity = progress / 0.3;
                    } else {
                        intensity = 1 - ((progress - 0.3) / 0.7);
                    }

                    const opacity = 0.5 + 0.4 * intensity;

                    // Only change opacity and color, NOT scale
                    this.fieldOrigin.material.opacity = opacity;
                    this.fieldOrigin.material.color.copy(pulseColor);

                    if (progress < 1) {
                        requestAnimationFrame(animate);
                    } else {
                        this.fieldOrigin.material.opacity = 0.5;
                    }
                };
                requestAnimationFrame(animate);
            }
        }


        // =========================================================================
        // FIELD CLOSURE ENGINE
        // Computes closure cycles dynamically from Pi digits (base 8)
        // Supports: Full closure mode, Step-by-step mode, Manual mode
        // =========================================================================

        class FieldClosureEngine {
            constructor(renderer) {
                this.renderer = renderer;
                this.isRunning = false;
                this.isManualMode = false;
                this.speedMultiplier = 1;
                this.portTimer = null;
                this.animationFrameId = null;

                // Timing
                this.pulseDuration = 1200;
                this.cyclePauseDelay = 800;

                // Pi traversal state
                this.piDigits = CONSTANTS.pi.digits_base8;
                this.faceVertices = CONSTANTS.faceVertices;
                this.vertexToFaces = CONSTANTS.vertexToFaces;
                this.vertexInfo = CONSTANTS.vertexInfo;
                this.currentPiIndex = 0;
                this.currentCycleIndex = 0;
                this.totalCycles = 10;

                // Cumulative sum for vertex calculation (vertex = cumsum % 8)
                this.cumsum = 0;

                // Track face completion state
                // Each face needs all 3 of its vertices visited to complete
                this.faceVisitedVertices = {};  // face -> Set of visited vertices
                this.completedFaces = new Set();

                // Track accumulated steps for display
                this.cycleStartPiIndex = 0;
                this.cycleStartCumsum = 0;
                this.cycleSteps = [];  // Array of step info
                this.cycleFaces = [];  // Array of completed face info
            }

            start() {
                if (this.isManualMode) return;
                this.isRunning = true;
                this.runFullClosure();
            }

            stop() {
                this.isRunning = false;
                if (this.portTimer) {
                    clearTimeout(this.portTimer);
                    this.portTimer = null;
                }
                if (this.animationFrameId) {
                    cancelAnimationFrame(this.animationFrameId);
                    this.animationFrameId = null;
                }
            }

            setManualMode(enabled) {
                this.isManualMode = enabled;
                if (enabled) {
                    this.stop();
                }
            }

            setSpeed(multiplier) {
                const wasManual = this.isManualMode;
                this.isManualMode = (multiplier === 0);
                this.speedMultiplier = multiplier || 1;

                if (wasManual && !this.isManualMode) {
                    // Switching from manual to auto - restart animation
                    this.start();
                } else if (!wasManual && this.isManualMode) {
                    // Switching to manual - stop animation
                    this.stop();
                }
            }

            getAdjustedTime(baseTime) {
                return baseTime / this.speedMultiplier;
            }

            /**
             * Step through one Pi digit at a time
             * Updates cumsum and calculates vertex = cumsum % 8
             * Tracks which vertices each face has seen - face completes when all 3 visited
             * Returns true if closure completed, false otherwise
             * 
             * STEP MODE FIELD CLOSURE:
             * The traversal uses cumulative sum modulo 8 to determine the current vertex:
             *   cumsum += pi_digit
             *   vertex = cumsum % 8
             * 
             * A face COMPLETES when all 3 of its constituent vertices have been visited
             * in the current cycle. A closure completes when all 8 faces have completed.
             */
            stepOnce() {
                if (this.currentPiIndex >= this.piDigits.length) {
                    // Reset to beginning when Pi digits exhausted
                    this.resetCycle();
                    this.currentPiIndex = 0;
                    this.cumsum = 0;
                    this.currentCycleIndex = 0;
                }

                const digit = this.piDigits[this.currentPiIndex];

                // CORRECT: Vertex is cumsum % 8, not the raw digit
                this.cumsum += digit;
                const vertex = this.cumsum % 8;
                const vertexInfo = this.vertexInfo[vertex];

                // Track step for display
                const stepInfo = {
                    piIndex: this.currentPiIndex,
                    digit: digit,
                    cumsum: this.cumsum,
                    vertex: vertex,
                    tetId: vertexInfo.tetId,
                    newlyCompletedFaces: []
                };
                this.cycleSteps.push(stepInfo);

                // ---------------------------------------------------------
                // FACE COMPLETION TRACKING
                // When a vertex is visited, mark it as seen for all faces
                // containing that vertex. A face completes when all 3 vertices visited.
                // ---------------------------------------------------------
                const facesContainingVertex = this.vertexToFaces[vertex];

                for (const faceName of facesContainingVertex) {
                    // Initialize tracking for this face if needed
                    if (!this.faceVisitedVertices[faceName]) {
                        this.faceVisitedVertices[faceName] = new Set();
                    }

                    // Mark this vertex as visited for this face
                    this.faceVisitedVertices[faceName].add(vertex);

                    // Check if face is now complete (all 3 vertices visited)
                    const faceData = this.faceVertices[faceName];
                    const visitedCount = this.faceVisitedVertices[faceName].size;

                    if (visitedCount === 3 && !this.completedFaces.has(faceName)) {
                        // Face just completed!
                        this.completedFaces.add(faceName);
                        stepInfo.newlyCompletedFaces.push(faceName);

                        this.cycleFaces.push({
                            name: faceName,
                            tetId: faceData.tetId,
                            role: faceData.role,
                            faceIdx: faceData.faceIdx,
                            completedAtStep: this.cycleSteps.length,
                            completedAtPiIndex: this.currentPiIndex,
                            triggerVertex: vertex
                        });

                        // Pulse the completed face
                        this.pulseSingleFace({
                            name: faceName,
                            tetId: faceData.tetId,
                            faceIdx: faceData.faceIdx,
                            role: faceData.role
                        }, 600);
                    }
                }

                // Update display
                this.updateStepStatusDisplay(stepInfo);

                this.currentPiIndex++;

                // ---------------------------------------------------------
                // CLOSURE COMPLETION CHECK
                // When all 8 faces have completed, closure is complete
                // ---------------------------------------------------------
                if (this.completedFaces.size === 8) {
                    // =====================================================
                    // VALIDATE STEP MODE CLOSURE
                    // =====================================================
                    this.validateClosureCycle(
                        this.cycleFaces,
                        this.completedFaces,
                        this.currentCycleIndex + 1
                    );

                    this.currentCycleIndex++;
                    if (this.currentCycleIndex >= this.totalCycles) {
                        this.currentCycleIndex = 0;
                    }
                    // Reset for next cycle after brief delay
                    setTimeout(() => this.resetCycle(), 800);
                    return true;
                }

                return false;
            }

            resetCycle() {
                this.cycleStartPiIndex = this.currentPiIndex;
                this.cycleStartCumsum = this.cumsum;
                this.faceVisitedVertices = {};
                this.completedFaces = new Set();
                this.cycleSteps = [];
                this.cycleFaces = [];
            }

            /**
             * Run full closure mode - all 8 faces pulse together
             */
            runFullClosure() {
                if (!this.isRunning || this.isManualMode) return;

                // Reset cycle tracking
                this.resetCycle();

                // Compute all faces for current closure
                const faces = this.computeCurrentClosureFaces();

                this.updateFullClosureStatusDisplay(faces);

                // Pulse all 8 faces simultaneously
                this.pulseAllFaces(faces, this.getAdjustedTime(this.pulseDuration));

                // Schedule next closure
                this.portTimer = setTimeout(() => {
                    this.currentCycleIndex = (this.currentCycleIndex + 1) % this.totalCycles;
                    if (this.currentCycleIndex === 0) {
                        // Reset to beginning of pi sequence
                        this.currentPiIndex = 0;
                        this.cumsum = 0;
                    }
                    this.runFullClosure();
                }, this.getAdjustedTime(this.pulseDuration + this.cyclePauseDelay));
            }

            /**
             * Compute all faces for one complete closure cycle.
             * 
             * CLOSURE GUARANTEES:
             * This function ensures that each closure satisfies the fundamental
             * requirements:
             * 
             * 1. ALL 8 FACES ACTIVATED: Every closure must activate all 8 faces
             *    (4 from Tet A + 4 from Tet B) before completion.
             * 
             * 2. NO DUPLICATE COUNTING: Each face is counted exactly once per closure.
             *    If a vertex is visited multiple times, it is only counted on
             *    first activation. Duplicates advance the Pi sequence but don't
             *    add to the closure.
             * 
             * 3. BIMETRIC BALANCE: Must have exactly 4 Tet A and 4 Tet B faces.
             *    This ensures field balance between the two tetrahedra.
             * 
             * 4. TIME FACE INCLUSION: Both TIME faces (FACE_A7 at vertex 7, FACE_B0 at
             *    vertex 0) must be included, ensuring proper temporal coupling.
             * 
             * The validation runs on every closure and logs errors to console if
             * any guarantee is violated (which should never happen with valid Pi digits).
             */
            computeCurrentClosureFaces() {
                const completedFaces = [];
                const completed = new Set();
                const faceVisited = {};  // face -> Set of visited vertices
                let idx = this.currentPiIndex;
                let cumsum = this.cumsum;

                // =========================================================
                // CLOSURE COMPUTATION
                // Traverse Pi digits until all 8 faces have completed
                // A face completes when all 3 of its vertices have been visited
                // =========================================================
                while (completed.size < 8 && idx < this.piDigits.length) {
                    const digit = this.piDigits[idx];
                    cumsum += digit;
                    const vertex = cumsum % 8;

                    // Mark this vertex as visited for all faces containing it
                    const facesContainingVertex = this.vertexToFaces[vertex];

                    for (const faceName of facesContainingVertex) {
                        if (!faceVisited[faceName]) {
                            faceVisited[faceName] = new Set();
                        }
                        faceVisited[faceName].add(vertex);

                        // Check if face just completed
                        if (faceVisited[faceName].size === 3 && !completed.has(faceName)) {
                            completed.add(faceName);
                            const faceData = this.faceVertices[faceName];
                            completedFaces.push({
                                name: faceName,
                                tetId: faceData.tetId,
                                role: faceData.role,
                                faceIdx: faceData.faceIdx,
                                vertex: vertex,  // Trigger vertex
                                piStep: idx
                            });
                        }
                    }
                    idx++;
                }

                // Update state for next closure
                this.currentPiIndex = idx;
                this.cumsum = cumsum;
                this.cycleFaces = completedFaces;

                // =========================================================
                // FIELD CLOSURE VALIDATION
                // Verify all guarantees are satisfied for this closure
                // =========================================================
                this.validateClosureCycle(completedFaces, completed, this.currentCycleIndex + 1);

                return completedFaces;
            }

            /**
             * CLOSURE VALIDATION SYSTEM
             * =========================
             * 
             * This validation runs on EVERY closure cycle to guarantee the integrity
             * of the Pi-driven field closure mechanism. Any violation is logged to
             * the console for debugging.
             * 
             * VALIDATIONS:
             * 
             * 1. COMPLETENESS: All 8 faces must be activated
             *    - If fewer than 8 faces, closure is incomplete (error)
             * 
             * 2. UNIQUENESS: Each face appears exactly once
             *    - Set size must equal array length (no duplicates)
             * 
             * 3. BIMETRIC BALANCE: Exactly 4 Tet A faces + 4 Tet B faces
             *    - Ensures field balance between the two tetrahedra
             * 
             * 4. TIME FACES: Both TIME faces (FACE_A7, FACE_B0) must be present
             *    - Required for proper temporal coupling in the structure
             * 
             * 5. SPATIAL FACES: All 6 spatial faces must be present
             *    - Required for full 3D spatial coupling
             * 
             * @param {Array} faces - Array of face objects activated in this closure
             * @param {Set} activatedSet - Set of face names for uniqueness check
             * @param {number} cycleNum - Current cycle number for error reporting
             */
            validateClosureCycle(faces, activatedSet, cycleNum) {
                const errors = [];

                // ---------------------------------------------------------
                // GUARANTEE 1: All 8 faces must be activated (completeness)
                // ---------------------------------------------------------
                if (faces.length !== 8) {
                    errors.push(`COMPLETENESS VIOLATION: Expected 8 faces, got ${faces.length}`);
                }

                // ---------------------------------------------------------
                // GUARANTEE 2: No duplicate faces (uniqueness)
                // The Set size should equal the array length
                // ---------------------------------------------------------
                if (activatedSet.size !== faces.length) {
                    errors.push(`UNIQUENESS VIOLATION: Set size ${activatedSet.size} != array length ${faces.length}`);
                }

                // ---------------------------------------------------------
                // GUARANTEE 3: Bimetric balance (4 Tet A + 4 Tet B)
                // ---------------------------------------------------------
                const tetACounts = faces.filter(f => f.tetId === 'A').length;
                const tetBCounts = faces.filter(f => f.tetId === 'B').length;

                if (tetACounts !== 4) {
                    errors.push(`BIMETRIC VIOLATION: Expected 4 Tet A faces, got ${tetACounts}`);
                }
                if (tetBCounts !== 4) {
                    errors.push(`BIMETRIC VIOLATION: Expected 4 Tet B faces, got ${tetBCounts}`);
                }

                // ---------------------------------------------------------
                // GUARANTEE 4: Both TIME faces must be present
                // TIME faces are at vertices 7 (Tet A apex) and 0 (Tet B apex)
                // ---------------------------------------------------------
                const faceNames = new Set(faces.map(f => f.name));
                const hasTimeA = faceNames.has('A7');  // TIME face from Tet A
                const hasTimeB = faceNames.has('B0');  // TIME face from Tet B

                if (!hasTimeA) {
                    errors.push('TIME FACE VIOLATION: Missing Tet A TIME face (A7)');
                }
                if (!hasTimeB) {
                    errors.push('TIME FACE VIOLATION: Missing Tet B TIME face (B0)');
                }

                // ---------------------------------------------------------
                // GUARANTEE 5: All 6 SPATIAL faces must be present
                // SPATIAL faces: A1, A2, A4 (Tet A) and B3, B5, B6 (Tet B)
                // ---------------------------------------------------------
                const spatialFaces = ['A1', 'A2', 'A4', 'B3', 'B5', 'B6'];
                const missingSpatial = spatialFaces.filter(sf => !faceNames.has(sf));

                if (missingSpatial.length > 0) {
                    errors.push(`SPATIAL FACE VIOLATION: Missing faces: ${missingSpatial.join(', ')}`);
                }

                // ---------------------------------------------------------
                // REPORT VALIDATION RESULTS
                // ---------------------------------------------------------
                if (errors.length > 0) {
                    // Log all errors as a group
                    console.error(`[FIELD CLOSURE VALIDATION FAILED] Cycle ${cycleNum}:`);
                    errors.forEach(err => console.error(`  - ${err}`));
                    console.error('  Faces activated:', Array.from(faceNames).sort().join(', '));

                    // This should NEVER happen with valid Pi digits
                    // If it does, there's a bug in the algorithm
                } else {
                    // Validation passed - log success at debug level
                    // Uncomment the next line to see successful validations:
                    // console.log(`[FIELD CLOSURE VALIDATED] Cycle ${cycleNum}: All 8 faces (4A+4B), both TIME faces present`);
                }

                return errors.length === 0;
            }

            /**
             * Pulse a single face (for step mode)
             */
            pulseSingleFace(face, duration) {
                const tetId = face.tetId;
                const faceIdx = face.faceIdx;

                // Get mesh
                const meshes = tetId === 'A'
                    ? this.renderer.faceMeshes.tetA
                    : this.renderer.faceMeshes.tetB;
                const mesh = meshes?.[faceIdx];

                // Get port aperture
                const tetPortData = tetId === 'A'
                    ? this.renderer.portApertureData?.tetA
                    : this.renderer.portApertureData?.tetB;
                const circle = tetPortData?.circles?.[faceIdx];

                if (!mesh) return;

                const baseColor = tetId === 'A' ? this.renderer.tetAColor : this.renderer.tetBColor;
                const origColor = new THREE.Color(baseColor);
                const targetColor = tetId === 'A' ? new THREE.Color(0x6da3cc) : new THREE.Color(0xccbe52);
                const baseOp = mesh.userData.originalOpacity;
                const maxOp = tetId === 'A' ? 0.68 : 0.56;

                // Field Origin for TIME faces
                const fieldOrigin = this.renderer.fieldOrigin;
                const isTimeFace = face.role === 'TIME';

                const startTime = performance.now();
                const flashDur = duration * 0.3;
                const fadeDur = duration * 0.7;

                const animate = (now) => {
                    const elapsed = now - startTime;
                    let intensity;

                    if (elapsed < flashDur) {
                        intensity = elapsed / flashDur;
                    } else if (elapsed < flashDur + fadeDur) {
                        intensity = 1 - ((elapsed - flashDur) / fadeDur);
                    } else {
                        intensity = 0;
                    }

                    // Animate mesh
                    mesh.material.color.lerpColors(origColor, targetColor, intensity);
                    mesh.material.opacity = baseOp + (maxOp - baseOp) * intensity;

                    // Animate port aperture
                    if (circle) {
                        const portOrig = new THREE.Color(circle.originalColor);
                        const portTarget = tetId === 'A' ? new THREE.Color(0xcccccc) : new THREE.Color(0xcccc88);
                        circle.line.material.color.lerpColors(portOrig, portTarget, intensity);
                        circle.line.material.opacity = circle.baseLineOpacity + (1.0 - circle.baseLineOpacity) * intensity;
                        circle.disc.material.color.lerpColors(portOrig, portTarget, intensity);
                        circle.disc.material.opacity = circle.baseDiscOpacity + (0.5 - circle.baseDiscOpacity) * intensity;
                    }

                    // Field Origin for TIME faces - opacity only, no scale
                    if (isTimeFace && fieldOrigin) {
                        fieldOrigin.material.opacity = 0.5 + 0.4 * intensity;
                    }

                    if (elapsed < flashDur + fadeDur) {
                        requestAnimationFrame(animate);
                    } else {
                        // Reset
                        mesh.material.color.copy(origColor);
                        mesh.material.opacity = baseOp;
                        if (circle) {
                            circle.line.material.color.set(circle.originalColor);
                            circle.line.material.opacity = circle.baseLineOpacity;
                            circle.disc.material.color.set(circle.originalColor);
                            circle.disc.material.opacity = circle.baseDiscOpacity;
                        }
                        if (isTimeFace && fieldOrigin) {
                            fieldOrigin.material.opacity = 0.5;
                        }
                    }
                };

                requestAnimationFrame(animate);
            }

            /**
             * Pulse all faces for full closure simultaneously
             */
            pulseAllFaces(faces, duration) {
                const allMeshData = [];
                const allPortData = [];

                faces.forEach(face => {
                    const tetId = face.tetId;
                    const faceIdx = face.faceIdx;

                    const meshes = tetId === 'A'
                        ? this.renderer.faceMeshes.tetA
                        : this.renderer.faceMeshes.tetB;
                    const mesh = meshes?.[faceIdx];

                    if (mesh) {
                        const baseColor = tetId === 'A' ? this.renderer.tetAColor : this.renderer.tetBColor;
                        allMeshData.push({
                            mesh,
                            origColor: new THREE.Color(baseColor),
                            targetColor: tetId === 'A' ? new THREE.Color(0x6da3cc) : new THREE.Color(0xccbe52),
                            baseOp: mesh.userData.originalOpacity,
                            maxOp: tetId === 'A' ? 0.68 : 0.56
                        });
                    }

                    const tetPortData = tetId === 'A'
                        ? this.renderer.portApertureData?.tetA
                        : this.renderer.portApertureData?.tetB;
                    const circle = tetPortData?.circles?.[faceIdx];

                    if (circle) {
                        allPortData.push({
                            line: circle.line,
                            disc: circle.disc,
                            origColor: new THREE.Color(circle.originalColor),
                            targetColor: tetId === 'A' ? new THREE.Color(0xcccccc) : new THREE.Color(0xcccc88),
                            baseLineOp: circle.baseLineOpacity,
                            baseDiscOp: circle.baseDiscOpacity,
                            maxLineOp: 1.0,
                            maxDiscOp: 0.5
                        });
                    }
                });

                const fieldOrigin = this.renderer.fieldOrigin;

                const startTime = performance.now();
                const flashDur = duration * 0.3;
                const fadeDur = duration * 0.7;

                const animate = (now) => {
                    if (!this.isRunning) return;

                    const elapsed = now - startTime;
                    let intensity;

                    if (elapsed < flashDur) {
                        intensity = elapsed / flashDur;
                    } else if (elapsed < flashDur + fadeDur) {
                        intensity = 1 - ((elapsed - flashDur) / fadeDur);
                    } else {
                        intensity = 0;
                    }

                    allMeshData.forEach(m => {
                        m.mesh.material.color.lerpColors(m.origColor, m.targetColor, intensity);
                        m.mesh.material.opacity = m.baseOp + (m.maxOp - m.baseOp) * intensity;
                    });

                    allPortData.forEach(p => {
                        p.line.material.color.lerpColors(p.origColor, p.targetColor, intensity);
                        p.line.material.opacity = p.baseLineOp + (p.maxLineOp - p.baseLineOp) * intensity;
                        p.disc.material.color.lerpColors(p.origColor, p.targetColor, intensity);
                        p.disc.material.opacity = p.baseDiscOp + (p.maxDiscOp - p.baseDiscOp) * intensity;
                    });

                    // Field Origin - opacity only, no scale
                    if (fieldOrigin) {
                        fieldOrigin.material.opacity = 0.5 + 0.4 * intensity;
                    }

                    if (elapsed < flashDur + fadeDur) {
                        this.animationFrameId = requestAnimationFrame(animate);
                    } else {
                        allMeshData.forEach(m => {
                            m.mesh.material.color.copy(m.origColor);
                            m.mesh.material.opacity = m.baseOp;
                        });
                        allPortData.forEach(p => {
                            p.line.material.color.copy(p.origColor);
                            p.line.material.opacity = p.baseLineOp;
                            p.disc.material.color.copy(p.origColor);
                            p.disc.material.opacity = p.baseDiscOp;
                        });
                        if (fieldOrigin) {
                            fieldOrigin.material.opacity = 0.5;
                        }
                    }
                };

                this.animationFrameId = requestAnimationFrame(animate);
            }

            /**
             * Update display for step mode - shows each step as it occurs
             * Now shows: step# | pi[idx]=digit | cumsum | vertex | faces touched/completed
             */
            updateStepStatusDisplay(stepInfo) {
                const container = document.getElementById('closure-steps');
                if (!container) return;

                const stepNum = this.cycleSteps.length;
                const tetClass = stepInfo.tetId === 'A' ? 'tet-a' : 'tet-b';

                // Build completed faces indicator
                let facesHtml = '';
                if (stepInfo.newlyCompletedFaces.length > 0) {
                    for (const faceName of stepInfo.newlyCompletedFaces) {
                        const faceData = this.faceVertices[faceName];
                        const faceClass = faceData.tetId === 'A' ? 'tet-a' : 'tet-b';
                        const isTime = faceData.role === 'TIME';
                        facesHtml += `<span class="step-face ${faceClass}">${faceName}</span>`;
                        if (isTime) facesHtml += `<span class="step-time">★</span>`;
                    }
                }

                let stepHtml = `<div class="closure-step active">`;
                stepHtml += `<span class="step-num">${stepNum}.</span>`;
                stepHtml += `<span class="step-pi">π[${stepInfo.piIndex}]=${stepInfo.digit}</span>`;
                stepHtml += `<span class="step-arrow">→</span>`;
                stepHtml += `<span class="step-cumsum">Σ=${stepInfo.cumsum}</span>`;
                stepHtml += `<span class="step-arrow">→</span>`;
                stepHtml += `<span class="step-vertex ${tetClass}">V${stepInfo.vertex}</span>`;
                if (facesHtml) {
                    stepHtml += `<span class="step-arrow">→</span>`;
                    stepHtml += facesHtml;
                }
                stepHtml += `<span class="step-count">[${this.completedFaces.size}/8]</span>`;
                stepHtml += `</div>`;

                // If this is the first step in cycle, clear and add header
                if (stepNum === 1) {
                    container.innerHTML = `<div class="closure-mode-label">Step Mode - Cycle ${this.currentCycleIndex + 1}</div>` + stepHtml;
                } else {
                    // Remove active class from previous steps and add new step
                    container.querySelectorAll('.closure-step').forEach(el => el.classList.remove('active'));
                    container.innerHTML += stepHtml;
                }

                // Scroll to show latest step if needed
                container.scrollTop = container.scrollHeight;
            }

            /**
             * Update display for full closure mode - shows all 8 faces in order
             */
            updateFullClosureStatusDisplay(faces) {
                const container = document.getElementById('closure-steps');
                if (!container) return;

                let html = `<div class="closure-mode-label">Full Closure - Cycle ${this.currentCycleIndex + 1}</div>`;

                faces.forEach((face, idx) => {
                    const tetClass = face.tetId === 'A' ? 'tet-a' : 'tet-b';
                    const isTime = face.role === 'TIME';

                    html += `<div class="closure-step">`;
                    html += `<span class="step-num">${idx + 1}.</span>`;
                    html += `<span class="step-pi">π${face.piStep}</span>`;
                    html += `<span class="step-arrow">=</span>`;
                    html += `<span class="step-pi">${face.vertex}</span>`;
                    html += `<span class="step-arrow">→</span>`;
                    html += `<span class="step-face ${tetClass}">${face.name}</span>`;
                    if (isTime) html += `<span class="step-time">★</span>`;
                    html += `</div>`;
                });

                container.innerHTML = html;
            }
        }


        // =========================================================================
        // APPLICATION INITIALIZATION
        // =========================================================================

        // Block all wheel/scroll events at the document level so they never
        // propagate back to a parent page or trigger browser-default behaviour
        // inside this iframe.  This prevents WebGL context crashes caused by
        // runaway zoom when embedded in a scrollable page.
        document.addEventListener('wheel', (e) => {
            e.preventDefault();
            e.stopPropagation();
        }, { passive: false });

        document.addEventListener('DOMContentLoaded', () => {
            // Hide UI panels permanently (landing mode)
            const style = document.createElement('style');
            style.textContent = `
                #left-panel { display: none !important; }
                #info-panel { display: none !important; }
                #panel-toggle { display: none !important; }
                #canvas-container { left: 0 !important; width: 100% !important; }
            `;
            document.head.appendChild(style);

            // Landing mode only when running standalone (not inside an iframe)
            const isLandingMode = (window === window.parent);
            // =====================================================================
            // PREFLIGHT VALIDATION: Verify Pi Base-8 Digits
            // Critical for correct Field Closure traversal
            // =====================================================================
            try {
                PiBase8Validator.assertValid();
                console.log('%c[Preflight] Pi base-8 validation PASSED - Field Closure ready',
                    'color: #4CAF50; font-weight: bold;');
            } catch (error) {
                console.error('%c[Preflight] CRITICAL ERROR:', 'color: #f44336; font-weight: bold;', error.message);
                // Display error to user
                document.body.innerHTML = `
                    <div style="position: fixed; inset: 0; background: #1a0a0a; color: #ff4444; 
                                display: flex; align-items: center; justify-content: center; 
                                font-family: monospace; text-align: center; padding: 40px;">
                        <div>
                            <h1 style="font-size: 24px; margin-bottom: 20px;">⚠ Pi Base-8 Validation Failed</h1>
                            <p style="color: #ffaa44;">${error.message}</p>
                            <p style="margin-top: 20px; color: #888;">
                                The field closure animation requires verified pi digits.<br>
                                Please ensure the digits match OEIS A006941.
                            </p>
                        </div>
                    </div>
                `;
                return;  // Halt initialization
            }

            // Initialize renderer
            const container = document.getElementById('canvas-container');
            const renderer = new StellatedOctahedronRenderer(container);
            renderer.init();

            // Start with axis locked (TIME floor horizontal)
            renderer.lockTimeFloor();

            // Initialize field closure engine
            const engine = new FieldClosureEngine(renderer);

            // =====================================================================
            // LANDING MODE: Launch Text (Tron style)
            // =====================================================================
            if (isLandingMode) {
                // Create floating LAUNCH text
                const launchGroup = new THREE.Group();
                launchGroup.name = 'launch-text';

                // Create stroke-only text matching merkaba edge style
                const canvas = document.createElement('canvas');
                canvas.width = 256;
                canvas.height = 256;
                const ctx = canvas.getContext('2d');

                // Subtle glow
                ctx.shadowColor = '#4488ff';
                ctx.shadowBlur = 10;

                // Stroke text only (no fill)
                ctx.strokeStyle = '#4488ff';
                ctx.textAlign = 'center';

                // Text labels removed for GRAVIS embed

                const texture = new THREE.CanvasTexture(canvas);
                const spriteMaterial = new THREE.SpriteMaterial({
                    map: texture,
                    transparent: true,
                    depthTest: false
                });
                const sprite = new THREE.Sprite(spriteMaterial);
                sprite.scale.set(1.5, 1.5, 1);
                launchGroup.add(sprite);

                // Position below the stellated octahedron
                launchGroup.position.set(0, -6.0, 0);
                renderer.scene.add(launchGroup);

                // Invisible click plane for easier clicking
                const clickPlaneGeometry = new THREE.PlaneGeometry(1.5, 1.5);
                const clickPlaneMaterial = new THREE.MeshBasicMaterial({
                    transparent: true,
                    opacity: 0,
                    side: THREE.DoubleSide
                });
                const clickPlane = new THREE.Mesh(clickPlaneGeometry, clickPlaneMaterial);
                launchGroup.add(clickPlane);

                // Animation state
                let launchAnimating = false;
                let launchProgress = 0;
                let isHovering = false;
                const startPos = launchGroup.position.clone();
                const targetPos = new THREE.Vector3(0, 0, 0); // Field origin

                // Raycaster for click detection
                const raycaster = new THREE.Raycaster();
                const mouse = new THREE.Vector2();

                // Click handler
                renderer.renderer.domElement.addEventListener('click', (event) => {
                    if (launchAnimating) return;

                    const rect = renderer.renderer.domElement.getBoundingClientRect();
                    mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
                    mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

                    raycaster.setFromCamera(mouse, renderer.camera);
                    const intersects = raycaster.intersectObjects([clickPlane]);

                    if (intersects.length > 0) {
                        launchAnimating = true;
                    }
                });

                // Hover cursor
                renderer.renderer.domElement.addEventListener('mousemove', (event) => {
                    if (launchAnimating) return;

                    const rect = renderer.renderer.domElement.getBoundingClientRect();
                    mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
                    mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

                    raycaster.setFromCamera(mouse, renderer.camera);
                    const intersects = raycaster.intersectObjects([clickPlane]);

                    isHovering = intersects.length > 0;
                    renderer.renderer.domElement.style.cursor = isHovering ? 'pointer' : 'default';
                });

                // Animation loop hook
                const originalRender = renderer.renderer.render.bind(renderer.renderer);
                renderer.renderer.render = function (scene, camera) {
                    // Gentle hover float
                    if (!launchAnimating) {
                        const float = Math.sin(Date.now() * 0.002) * 0.05;
                        launchGroup.position.y = startPos.y + float;

                        // Hover scale
                        const hoverScale = isHovering ? 1.1 : 1;
                        launchGroup.scale.setScalar(hoverScale);
                    }

                    // Launch animation
                    if (launchAnimating) {
                        launchProgress += 0.02;

                        // Ease in-out cubic
                        const t = Math.min(launchProgress, 1);
                        const eased = t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;

                        // Move toward field origin
                        launchGroup.position.lerpVectors(startPos, targetPos, eased);

                        // Scale down
                        const scale = Math.max(0.01, 1 - eased * 0.9);
                        launchGroup.scale.setScalar(scale);

                        // Fade out
                        spriteMaterial.opacity = Math.max(0, 1 - eased * 1.2);

                        // Redirect when done
                        if (launchProgress >= 1.2) {
                            window.location.href = '/app';
                        }
                    }

                    originalRender(scene, camera);
                };
            }

            // =====================================================================
            // FIELD MECHANICS CALCULATIONS
            // =====================================================================
            // 
            // All calculations derive from fundamental constants and the k=4
            // tetrahedral topology. Equations are documented with formal definitions.
            //
            // Reference: DFP Paper VI, GFD Model V2 validation suite
            // =====================================================================

            // -----------------------------------------------------------------
            // PHYSICAL CONSTANTS (CODATA 2018)
            // -----------------------------------------------------------------
            const HBAR = 1.054571817e-34;       // ℏ: Reduced Planck constant (J·s)
            const H_PLANCK = 6.62607015e-34;    // h: Planck constant (J·s)
            const C = 299792458;                // c: Speed of light in vacuum (m/s)
            const M_E = 9.1093837015e-31;       // mₑ: Electron mass (kg)
            const E_CHARGE = 1.602176634e-19;   // e: Elementary charge (C)
            const EPSILON_0 = 8.8541878128e-12; // ε₀: Vacuum permittivity (F/m)
            const G = 6.67430e-11;              // G: Gravitational constant (m³/kg/s²)

            // -----------------------------------------------------------------
            // TOPOLOGICAL CONSTANTS
            // -----------------------------------------------------------------
            const k = CONSTANTS.topology.k;     // k = 4: Closure constant (simplex theorem: d+1)
            const d = k - 1;                    // d = 3: Spatial dimensions

            // -----------------------------------------------------------------
            // FIELD ENVELOPE
            // -----------------------------------------------------------------
            // Definition: The reduced Compton wavelength of the electron
            // 
            // Equation:  λ̄_C = ℏ / (mₑ × c)
            // 
            // This is the characteristic quantum length scale where the electron's
            // wave nature becomes significant. It sets the scale for Field Closure
            // dynamics and determines the settlement frequency.
            //
            // Note: This differs from the classical electron radius (r_e = 2.82 fm)
            // which is the EM self-energy scale.
            // -----------------------------------------------------------------
            const REDUCED_COMPTON = HBAR / (M_E * C);  // λ̄_C ≈ 3.86×10⁻¹³ m = 386 fm
            const fieldEnvelopeM = REDUCED_COMPTON;
            const fieldEnvelopeFm = fieldEnvelopeM * 1e15;  // Convert to femtometers

            // -----------------------------------------------------------------
            // APERTURE THROUGHPUT
            // -----------------------------------------------------------------
            // Definition: Geometric efficiency of tetrahedral ports on spherical field
            //
            // Equation:  η = √(π/k) = √(π/4) ≈ 0.886 = 88.6%
            //
            // Physical meaning: The k=4 tetrahedral faces inscribed in a sphere
            // cover a fraction √(π/k) of the spherical surface. This represents
            // the coupling efficiency through the Coupling Ports.
            //
            // The inverse √(k/π) ≈ 1.128 is the "port ratio" that converts between
            // tetrahedral (flat) and spherical (curved) descriptions.
            // -----------------------------------------------------------------
            const portRatio = Math.sqrt(k / Math.PI);        // √(k/π) ≈ 1.128
            const apertureThroughput = Math.sqrt(Math.PI / k);  // √(π/k) ≈ 0.886

            // -----------------------------------------------------------------
            // CLOSURE (SETTLEMENT) FREQUENCY
            // -----------------------------------------------------------------
            // Definition: Fundamental rate of Field Closure cycles
            //
            // Equation:  f = c / λ̄_C = (mₑ × c²) / ℏ
            //
            // This is the electron Compton frequency - the rate at which the
            // field can respond to electron-scale changes. It represents the
            // "clock speed" of Field Closure dynamics.
            //
            // Derivation: From E = ℏω and E = mₑc², we get ω = mₑc²/ℏ,
            //             so f = ω/(2π) = mₑc²/(h) ≈ 1.24×10²⁰ Hz
            //
            // Note: Using reduced Compton wavelength gives f = c/λ̄_C ≈ 7.76×10²⁰ Hz
            // -----------------------------------------------------------------
            const closureFrequency = C / REDUCED_COMPTON;  // f ≈ 7.76×10²⁰ Hz

            // -----------------------------------------------------------------
            // CLOSURE PERIOD
            // -----------------------------------------------------------------
            // Definition: Time for one complete Field Closure cycle
            //
            // Equation:  T = 1/f = λ̄_C / c = ℏ / (mₑ × c²)
            //
            // This is in the zeptosecond range (~10⁻²¹ s), representing the
            // fundamental "tick" of the electron's internal dynamics.
            // -----------------------------------------------------------------
            const closurePeriod = 1 / closureFrequency;  // T ≈ 1.29×10⁻²¹ s

            // -----------------------------------------------------------------
            // SPHERE PACKING: THE 12-NEIGHBOR TOPOLOGY IN (3+1) SPACETIME
            // -----------------------------------------------------------------
            // A gravity field in k=4 packing has 12 neighboring gravity fields
            // arranged in cuboctahedral geometry (closest sphere packing).
            //
            // In (3+1) spacetime:
            //   - 12 neighbors = 12 ports
            //   - 4 ACTIVE ports (Tetrahedron A)
            //   - 8 CLOSED ports (structural blocking)
            //   - 4 + 8 = 12
            //
            // Tetrahedron B exists in subspace. It is required to balance
            // the field but is separate from the 12-port (3+1) structure.
            // -----------------------------------------------------------------
            const totalPorts = 12;                        // 12 sphere-packing neighbors
            const activePorts = k;                        // k = 4 active (Tet A)
            const closedPorts = totalPorts - activePorts; // 8 closed (structural blocking)

            // -----------------------------------------------------------------
            // INFORMATION CONTENT: BITS PER CLOSURE
            // -----------------------------------------------------------------
            // Definition: Information processed per complete closure cycle
            //
            // Equation:  bits = (2k vertices) × (d bits per vertex) = 8 × 3 = 24
            //
            // Physical meaning: The stellated octahedron has 2k = 8 vertices.
            // Each vertex requires d = log₂(2k) = 3 bits to address (0-7 = 2³).
            // One complete closure visits all 8 vertices, encoding 24 bits total.
            //
            // This is the information throughput per Field Closure cycle.
            // -----------------------------------------------------------------
            const totalVertices = 2 * k;                  // 2k = 8 vertices
            const bitsPerVertex = d;                      // d = 3 bits (log₂(8) = 3)
            const bitsPerClosure = totalVertices * bitsPerVertex;  // 8 × 3 = 24 bits

            // -----------------------------------------------------------------
            // DISPLAY CALCULATED VALUES
            // -----------------------------------------------------------------

            // Field Envelope
            document.getElementById('field-envelope').textContent =
                `${fieldEnvelopeFm.toFixed(3)} fm`;

            // Aperture Throughput
            document.getElementById('aperture-throughput').textContent =
                `${(apertureThroughput * 100).toFixed(1)}%`;

            // Closure Frequency (with proper exponent formatting)
            const freqExp = Math.floor(Math.log10(closureFrequency));
            const freqMant = closureFrequency / Math.pow(10, freqExp);
            const freqExpSuperscript = String(freqExp).split('').map(c =>
                c === '-' ? '⁻' : '⁰¹²³⁴⁵⁶⁷⁸⁹'[parseInt(c)]
            ).join('');
            document.getElementById('settlement-freq').textContent =
                `${freqMant.toFixed(2)}×10${freqExpSuperscript} Hz`;

            // Closure Period (with proper exponent formatting)
            const periodExp = Math.floor(Math.log10(closurePeriod));
            const periodMant = closurePeriod / Math.pow(10, periodExp);
            const periodExpSuperscript = String(periodExp).split('').map(c =>
                c === '-' ? '⁻' : '⁰¹²³⁴⁵⁶⁷⁸⁹'[parseInt(c)]
            ).join('');
            document.getElementById('closure-period').textContent =
                `${periodMant.toFixed(1)}×10${periodExpSuperscript} s`;

            // Bits per Closure
            document.getElementById('bits-per-closure').textContent =
                `${bitsPerClosure} bits`;

            // =====================================================================
            // PANEL TOGGLE
            // =====================================================================

            const leftPanel = document.getElementById('left-panel');
            const panelToggle = document.getElementById('panel-toggle');

            panelToggle.addEventListener('click', () => {
                leftPanel.classList.toggle('open');
                panelToggle.textContent = leftPanel.classList.contains('open') ? '✕' : '☰';
            });

            // =====================================================================
            // STRUCTURE VISIBILITY & ANIMATION CONTROLS
            // Level 5 = Field Closure animation running
            // Levels 1-4 = Static view (no animation)
            // =====================================================================

            const structureButtons = {
                'btn-tet-a': 1,
                'btn-tet-b': 2,
                'btn-origin': 3,
                'btn-ports': 4,
                'btn-field-closure': 5,
                'btn-field-closure-step': 6
            };

            let currentVisibilityLevel = 5; // Start with Field Closure active
            let autoStepInterval = null; // Timer for auto-stepping

            // Reset all face/port highlights to their original state
            // Clear the closure steps display
            function clearClosureSteps(message = '') {
                const container = document.getElementById('closure-steps');
                if (container) {
                    container.innerHTML = message ?
                        `<div class="closure-mode-label">${message}</div>` : '';
                }
            }

            function resetHighlights() {
                // Reset Tet A faces
                renderer.faceMeshes.tetA.forEach(mesh => {
                    mesh.material.color.setHex(renderer.tetAColor);
                    mesh.material.opacity = mesh.userData.originalOpacity;
                });

                // Reset Tet B faces
                renderer.faceMeshes.tetB.forEach(mesh => {
                    mesh.material.color.setHex(renderer.tetBColor);
                    mesh.material.opacity = mesh.userData.originalOpacity;
                });

                // Reset port apertures
                if (renderer.portApertureData) {
                    renderer.portApertureData.tetA.circles.forEach(circle => {
                        circle.line.material.color.setHex(circle.originalColor);
                        circle.line.material.opacity = circle.baseLineOpacity;
                        circle.disc.material.color.setHex(circle.originalColor);
                        circle.disc.material.opacity = circle.baseDiscOpacity;
                    });
                    renderer.portApertureData.tetB.circles.forEach(circle => {
                        circle.line.material.color.setHex(circle.originalColor);
                        circle.line.material.opacity = circle.baseLineOpacity;
                        circle.disc.material.color.setHex(circle.originalColor);
                        circle.disc.material.opacity = circle.baseDiscOpacity;
                    });
                }

                // Reset Field Origin - opacity only (scale is fixed)
                if (renderer.fieldOrigin) {
                    renderer.fieldOrigin.material.opacity = 0.5;
                }

                // Clear closure steps display
                clearClosureSteps('Select Field Closure to begin');
            }

            // Stop auto-step timer
            function stopAutoStep() {
                if (autoStepInterval) {
                    clearInterval(autoStepInterval);
                    autoStepInterval = null;
                }
                document.getElementById('btn-field-closure-step').classList.remove('active');
            }

            function updateStructureButtons(level, isFieldClosureClick = false, isAutoStepClick = false) {
                currentVisibilityLevel = level;

                // Set visibility (levels 1-4 for static, 5-6 show full structure)
                if (level >= 5) {
                    renderer.setVisibilityLevel(4); // Show all structure for field closure modes
                } else {
                    renderer.setVisibilityLevel(level);
                }

                // Update button active states
                Object.entries(structureButtons).forEach(([btnId, btnLevel]) => {
                    const btn = document.getElementById(btnId);
                    if (btn) {
                        // For Field Closure Step, only show active when auto-stepping
                        if (btnId === 'btn-field-closure-step') {
                            btn.classList.toggle('active', autoStepInterval !== null);
                        } else if (btnId === 'btn-field-closure') {
                            // Field Closure active at level 5+ but not when Step is active
                            btn.classList.toggle('active', level >= 5 && autoStepInterval === null);
                        } else {
                            // Structure buttons active up to their l
                            btn.classList.toggle('active', btnLevel <= level);
                        }
                    }
                });
            }

            // Initialize with Field Closure active and running
            updateStructureButtons(5);
            engine.setManualMode(false);
            engine.speedMultiplier = 1;
            engine.start(); // Start continuous field closure cycling

            // Add click handlers for each structure button
            Object.entries(structureButtons).forEach(([btnId, level]) => {
                const btn = document.getElementById(btnId);
                if (btn) {
                    btn.addEventListener('click', () => {
                        if (btnId === 'btn-field-closure') {
                            // Field Closure button: continuous full closure cycles
                            stopAutoStep();
                            engine.stop();
                            resetHighlights();
                            updateStructureButtons(5, true, false);
                            engine.setManualMode(false);
                            engine.speedMultiplier = 1;
                            engine.resetCycle();
                            engine.currentPiIndex = 0;
                            engine.currentCycleIndex = 0;
                            engine.start(); // Start continuous cycling

                        } else if (btnId === 'btn-field-closure-step') {
                            // Field Closure (Step) button: toggle auto-stepping every 1s
                            if (autoStepInterval) {
                                // Stop auto-stepping
                                stopAutoStep();
                                engine.stop();
                                resetHighlights();
                                engine.resetCycle();
                                engine.currentPiIndex = 0;
                                engine.currentCycleIndex = 0;
                                updateStructureButtons(5, false, false);
                            } else {
                                // Start auto-stepping
                                engine.stop();
                                resetHighlights();
                                engine.resetCycle();
                                engine.currentPiIndex = 0;
                                engine.currentCycleIndex = 0;
                                updateStructureButtons(6, false, true);
                                engine.setManualMode(true);

                                // Mark button as active
                                btn.classList.add('active');

                                // Step immediately, then every 1 second
                                engine.stepOnce();
                                autoStepInterval = setInterval(() => {
                                    engine.stepOnce();
                                }, 1000);
                            }
                        } else {
                            // Other buttons (Tet A, Tet B, Origin, Ports)
                            // Stop everything and reset before changing visibility
                            stopAutoStep();
                            engine.stop();
                            resetHighlights();
                            engine.resetCycle();
                            engine.currentPiIndex = 0;
                            engine.currentCycleIndex = 0;
                            updateStructureButtons(level);
                        }
                    });
                }
            });

            // =====================================================================
            // CONTROL BUTTON HANDLERS
            // =====================================================================

            const btnLock = document.getElementById('btn-lock');
            const btnReset = document.getElementById('btn-reset');

            // Lock button starts active (locked state)
            btnLock.addEventListener('click', () => {
                const isLocked = renderer.toggleAxisLock();
                btnLock.textContent = isLocked ? 'Unlock' : 'Lock';
                btnLock.classList.toggle('active', isLocked);
            });

            btnReset.addEventListener('click', () => {
                renderer.resetCamera();
                // Re-lock after reset if it was locked
                if (renderer.axisLocked) {
                    renderer.lockTimeFloor();
                }
            });

            // -----------------------------------------------------------------
            // DEFINITIONS MODAL
            // -----------------------------------------------------------------
            const definitionsModal = new DefinitionsModal();
            const btnDefinitions = document.getElementById('btn-definitions');

            btnDefinitions.addEventListener('click', () => {
                definitionsModal.toggle();
            });
        });
    </script>
</body>

</html>
<!--
================================================================================
END OF FILE
================================================================================
DFP: Gravity Field Dynamics Visual v1
Copyright (c) 2026 Stephen Nelson / Field Dynamics
MIT License - See header for full license text
================================================================================
-->